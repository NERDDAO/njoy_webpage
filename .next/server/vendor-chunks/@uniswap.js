"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@uniswap";
exports.ids = ["vendor-chunks/@uniswap"];
exports.modules = {

/***/ "(ssr)/./node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARGENT_WALLET_DETECTOR_ADDRESS: () => (/* binding */ ARGENT_WALLET_DETECTOR_ADDRESS),\n/* harmony export */   CHAIN_TO_ADDRESSES_MAP: () => (/* binding */ CHAIN_TO_ADDRESSES_MAP),\n/* harmony export */   ChainId: () => (/* binding */ ChainId),\n/* harmony export */   CurrencyAmount: () => (/* binding */ CurrencyAmount),\n/* harmony export */   ENS_REGISTRAR_ADDRESSES: () => (/* binding */ ENS_REGISTRAR_ADDRESSES),\n/* harmony export */   Ether: () => (/* binding */ Ether),\n/* harmony export */   Fraction: () => (/* binding */ Fraction),\n/* harmony export */   GOVERNANCE_ALPHA_V0_ADDRESSES: () => (/* binding */ GOVERNANCE_ALPHA_V0_ADDRESSES),\n/* harmony export */   GOVERNANCE_ALPHA_V1_ADDRESSES: () => (/* binding */ GOVERNANCE_ALPHA_V1_ADDRESSES),\n/* harmony export */   GOVERNANCE_BRAVO_ADDRESSES: () => (/* binding */ GOVERNANCE_BRAVO_ADDRESSES),\n/* harmony export */   MERKLE_DISTRIBUTOR_ADDRESS: () => (/* binding */ MERKLE_DISTRIBUTOR_ADDRESS),\n/* harmony export */   MIXED_ROUTE_QUOTER_V1_ADDRESSES: () => (/* binding */ MIXED_ROUTE_QUOTER_V1_ADDRESSES),\n/* harmony export */   MULTICALL_ADDRESSES: () => (/* binding */ MULTICALL_ADDRESSES),\n/* harmony export */   MaxUint256: () => (/* binding */ MaxUint256),\n/* harmony export */   NONFUNGIBLE_POSITION_MANAGER_ADDRESSES: () => (/* binding */ NONFUNGIBLE_POSITION_MANAGER_ADDRESSES),\n/* harmony export */   NativeCurrency: () => (/* binding */ NativeCurrency),\n/* harmony export */   NativeCurrencyName: () => (/* binding */ NativeCurrencyName),\n/* harmony export */   Percent: () => (/* binding */ Percent),\n/* harmony export */   Price: () => (/* binding */ Price),\n/* harmony export */   QUOTER_ADDRESSES: () => (/* binding */ QUOTER_ADDRESSES),\n/* harmony export */   Rounding: () => (/* binding */ Rounding),\n/* harmony export */   SOCKS_CONTROLLER_ADDRESSES: () => (/* binding */ SOCKS_CONTROLLER_ADDRESSES),\n/* harmony export */   SUPPORTED_CHAINS: () => (/* binding */ SUPPORTED_CHAINS),\n/* harmony export */   SWAP_ROUTER_02_ADDRESSES: () => (/* binding */ SWAP_ROUTER_02_ADDRESSES),\n/* harmony export */   TICK_LENS_ADDRESSES: () => (/* binding */ TICK_LENS_ADDRESSES),\n/* harmony export */   TIMELOCK_ADDRESSES: () => (/* binding */ TIMELOCK_ADDRESSES),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TradeType: () => (/* binding */ TradeType),\n/* harmony export */   UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS: () => (/* binding */ UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS),\n/* harmony export */   UNI_ADDRESSES: () => (/* binding */ UNI_ADDRESSES),\n/* harmony export */   V2_FACTORY_ADDRESS: () => (/* binding */ V2_FACTORY_ADDRESS),\n/* harmony export */   V2_FACTORY_ADDRESSES: () => (/* binding */ V2_FACTORY_ADDRESSES),\n/* harmony export */   V2_ROUTER_ADDRESS: () => (/* binding */ V2_ROUTER_ADDRESS),\n/* harmony export */   V2_ROUTER_ADDRESSES: () => (/* binding */ V2_ROUTER_ADDRESSES),\n/* harmony export */   V3_CORE_FACTORY_ADDRESSES: () => (/* binding */ V3_CORE_FACTORY_ADDRESSES),\n/* harmony export */   V3_MIGRATOR_ADDRESSES: () => (/* binding */ V3_MIGRATOR_ADDRESSES),\n/* harmony export */   WETH9: () => (/* binding */ WETH9),\n/* harmony export */   computePriceImpact: () => (/* binding */ computePriceImpact),\n/* harmony export */   sortedInsert: () => (/* binding */ sortedInsert),\n/* harmony export */   sqrt: () => (/* binding */ sqrt),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress)\n/* harmony export */ });\n/* harmony import */ var jsbi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsbi */ \"(ssr)/./node_modules/jsbi/dist/jsbi.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var decimal_js_light__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! decimal.js-light */ \"(ssr)/./node_modules/decimal.js-light/decimal.mjs\");\n/* harmony import */ var big_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big.js */ \"(ssr)/./node_modules/big.js/big.mjs\");\n/* harmony import */ var toformat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! toformat */ \"(ssr)/./node_modules/toformat/toFormat.js\");\n/* harmony import */ var toformat__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(toformat__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\n\n\n\n\n\n\n\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar ChainId;\n\n(function (ChainId) {\n  ChainId[ChainId[\"MAINNET\"] = 1] = \"MAINNET\";\n  ChainId[ChainId[\"GOERLI\"] = 5] = \"GOERLI\";\n  ChainId[ChainId[\"SEPOLIA\"] = 11155111] = \"SEPOLIA\";\n  ChainId[ChainId[\"OPTIMISM\"] = 10] = \"OPTIMISM\";\n  ChainId[ChainId[\"OPTIMISM_GOERLI\"] = 420] = \"OPTIMISM_GOERLI\";\n  ChainId[ChainId[\"OPTIMISM_SEPOLIA\"] = 11155420] = \"OPTIMISM_SEPOLIA\";\n  ChainId[ChainId[\"ARBITRUM_ONE\"] = 42161] = \"ARBITRUM_ONE\";\n  ChainId[ChainId[\"ARBITRUM_GOERLI\"] = 421613] = \"ARBITRUM_GOERLI\";\n  ChainId[ChainId[\"POLYGON\"] = 137] = \"POLYGON\";\n  ChainId[ChainId[\"POLYGON_MUMBAI\"] = 80001] = \"POLYGON_MUMBAI\";\n  ChainId[ChainId[\"CELO\"] = 42220] = \"CELO\";\n  ChainId[ChainId[\"CELO_ALFAJORES\"] = 44787] = \"CELO_ALFAJORES\";\n  ChainId[ChainId[\"GNOSIS\"] = 100] = \"GNOSIS\";\n  ChainId[ChainId[\"MOONBEAM\"] = 1284] = \"MOONBEAM\";\n  ChainId[ChainId[\"BNB\"] = 56] = \"BNB\";\n  ChainId[ChainId[\"AVALANCHE\"] = 43114] = \"AVALANCHE\";\n  ChainId[ChainId[\"BASE_GOERLI\"] = 84531] = \"BASE_GOERLI\";\n  ChainId[ChainId[\"BASE\"] = 8453] = \"BASE\";\n})(ChainId || (ChainId = {}));\n\nvar SUPPORTED_CHAINS = [ChainId.MAINNET, ChainId.OPTIMISM, ChainId.OPTIMISM_GOERLI, ChainId.OPTIMISM_SEPOLIA, ChainId.ARBITRUM_ONE, ChainId.ARBITRUM_GOERLI, ChainId.POLYGON, ChainId.POLYGON_MUMBAI, ChainId.GOERLI, ChainId.SEPOLIA, ChainId.CELO_ALFAJORES, ChainId.CELO, ChainId.BNB, ChainId.AVALANCHE, ChainId.BASE, ChainId.BASE_GOERLI];\nvar NativeCurrencyName;\n\n(function (NativeCurrencyName) {\n  // Strings match input for CLI\n  NativeCurrencyName[\"ETHER\"] = \"ETH\";\n  NativeCurrencyName[\"MATIC\"] = \"MATIC\";\n  NativeCurrencyName[\"CELO\"] = \"CELO\";\n  NativeCurrencyName[\"GNOSIS\"] = \"XDAI\";\n  NativeCurrencyName[\"MOONBEAM\"] = \"GLMR\";\n  NativeCurrencyName[\"BNB\"] = \"BNB\";\n  NativeCurrencyName[\"AVAX\"] = \"AVAX\";\n})(NativeCurrencyName || (NativeCurrencyName = {}));\n\nvar _CHAIN_TO_ADDRESSES_M, _GOVERNANCE_ALPHA_V1_, _GOVERNANCE_BRAVO_ADD, _MERKLE_DISTRIBUTOR_A, _ARGENT_WALLET_DETECT, _SOCKS_CONTROLLER_ADD;\nvar DEFAULT_NETWORKS = [ChainId.MAINNET, ChainId.GOERLI, ChainId.SEPOLIA];\n\nfunction constructSameAddressMap(address, additionalNetworks) {\n  if (additionalNetworks === void 0) {\n    additionalNetworks = [];\n  }\n\n  return DEFAULT_NETWORKS.concat(additionalNetworks).reduce(function (memo, chainId) {\n    memo[chainId] = address;\n    return memo;\n  }, {});\n}\n\nvar UNI_ADDRESSES = /*#__PURE__*/constructSameAddressMap('0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984', [ChainId.OPTIMISM, ChainId.ARBITRUM_ONE, ChainId.POLYGON, ChainId.POLYGON_MUMBAI, ChainId.SEPOLIA]);\nvar UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS = '0x8B799381ac40b838BBA4131ffB26197C432AFe78';\nvar V2_FACTORY_ADDRESS = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f';\nvar V2_FACTORY_ADDRESSES = /*#__PURE__*/constructSameAddressMap(V2_FACTORY_ADDRESS, [ChainId.POLYGON, ChainId.OPTIMISM, ChainId.CELO, ChainId.ARBITRUM_ONE, ChainId.BNB, ChainId.AVALANCHE, ChainId.BASE]);\nvar V2_ROUTER_ADDRESS = '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D';\nvar V2_ROUTER_ADDRESSES = /*#__PURE__*/constructSameAddressMap(V2_ROUTER_ADDRESS); // Networks that share most of the same addresses i.e. Mainnet, Goerli, Optimism, Arbitrum, Polygon\n\nvar DEFAULT_ADDRESSES = {\n  v3CoreFactoryAddress: '0x1F98431c8aD98523631AE4a59f267346ea31F984',\n  multicallAddress: '0x1F98415757620B543A52E61c46B32eB19261F984',\n  quoterAddress: '0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6',\n  v3MigratorAddress: '0xA5644E29708357803b5A882D272c41cC0dF92B34',\n  nonfungiblePositionManagerAddress: '0xC36442b4a4522E871399CD717aBDD847Ab11FE88'\n};\n\nvar MAINNET_ADDRESSES = /*#__PURE__*/_extends({}, DEFAULT_ADDRESSES, {\n  v1MixedRouteQuoterAddress: '0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E'\n});\n\nvar GOERLI_ADDRESSES = /*#__PURE__*/_extends({}, DEFAULT_ADDRESSES, {\n  v1MixedRouteQuoterAddress: '0xBa60b6e6fF25488308789E6e0A65D838be34194e'\n});\n\nvar OPTIMISM_ADDRESSES = DEFAULT_ADDRESSES;\n\nvar ARBITRUM_ONE_ADDRESSES = /*#__PURE__*/_extends({}, DEFAULT_ADDRESSES, {\n  multicallAddress: '0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB',\n  tickLensAddress: '0xbfd8137f7d1516D3ea5cA83523914859ec47F573'\n});\n\nvar POLYGON_ADDRESSES = DEFAULT_ADDRESSES; // celo v3 addresses\n\nvar CELO_ADDRESSES = {\n  v3CoreFactoryAddress: '0xAfE208a311B21f13EF87E33A90049fC17A7acDEc',\n  multicallAddress: '0x633987602DE5C4F337e3DbF265303A1080324204',\n  quoterAddress: '0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8',\n  v3MigratorAddress: '0x3cFd4d48EDfDCC53D3f173F596f621064614C582',\n  nonfungiblePositionManagerAddress: '0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A',\n  tickLensAddress: '0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D'\n}; // BNB v3 addresses\n\nvar BNB_ADDRESSES = {\n  v3CoreFactoryAddress: '0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7',\n  multicallAddress: '0x963Df249eD09c358A4819E39d9Cd5736c3087184',\n  quoterAddress: '0x78D78E420Da98ad378D7799bE8f4AF69033EB077',\n  v3MigratorAddress: '0x32681814957e0C13117ddc0c2aba232b5c9e760f',\n  nonfungiblePositionManagerAddress: '0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613',\n  tickLensAddress: '0xD9270014D396281579760619CCf4c3af0501A47C',\n  swapRouter02Address: '0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2'\n}; // optimism goerli addresses\n\nvar OPTIMISM_GOERLI_ADDRESSES = {\n  v3CoreFactoryAddress: '0xB656dA17129e7EB733A557f4EBc57B76CFbB5d10',\n  multicallAddress: '0x07F2D8a2a02251B62af965f22fC4744A5f96BCCd',\n  quoterAddress: '0x9569CbA925c8ca2248772A9A4976A516743A246F',\n  v3MigratorAddress: '0xf6c55fBe84B1C8c3283533c53F51bC32F5C7Aba8',\n  nonfungiblePositionManagerAddress: '0x39Ca85Af2F383190cBf7d7c41ED9202D27426EF6',\n  tickLensAddress: '0xe6140Bd164b63E8BfCfc40D5dF952f83e171758e'\n}; // optimism sepolia addresses\n\nvar OPTIMISM_SEPOLIA_ADDRESSES = {\n  v3CoreFactoryAddress: '0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF',\n  multicallAddress: '0x80e4e06841bb76AA9735E0448cB8d003C0EF009a',\n  quoterAddress: '0x0FBEa6cf957d95ee9313490050F6A0DA68039404',\n  v3MigratorAddress: '0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07',\n  nonfungiblePositionManagerAddress: '0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d',\n  tickLensAddress: '0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5'\n}; // arbitrum goerli v3 addresses\n\nvar ARBITRUM_GOERLI_ADDRESSES = {\n  v3CoreFactoryAddress: '0x4893376342d5D7b3e31d4184c08b265e5aB2A3f6',\n  multicallAddress: '0x8260CB40247290317a4c062F3542622367F206Ee',\n  quoterAddress: '0x1dd92b83591781D0C6d98d07391eea4b9a6008FA',\n  v3MigratorAddress: '0xA815919D2584Ac3F76ea9CB62E6Fd40a43BCe0C3',\n  nonfungiblePositionManagerAddress: '0x622e4726a167799826d1E1D150b076A7725f5D81',\n  tickLensAddress: '0xb52429333da969a0C79a60930a4Bf0020E5D1DE8'\n}; // sepolia v3 addresses\n\nvar SEPOLIA_ADDRESSES = {\n  v3CoreFactoryAddress: '0x0227628f3F023bb0B980b67D528571c95c6DaC1c',\n  multicallAddress: '0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07',\n  quoterAddress: '0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3',\n  v3MigratorAddress: '0x729004182cF005CEC8Bd85df140094b6aCbe8b15',\n  nonfungiblePositionManagerAddress: '0x1238536071E1c677A632429e3655c799b22cDA52',\n  tickLensAddress: '0xd7f33bcdb21b359c8ee6f0251d30e94832baad07'\n}; // Avalanche v3 addresses\n\nvar AVALANCHE_ADDRESSES = {\n  v3CoreFactoryAddress: '0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD',\n  multicallAddress: '0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2',\n  quoterAddress: '0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F',\n  v3MigratorAddress: '0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97',\n  nonfungiblePositionManagerAddress: '0x655C406EBFa14EE2006250925e54ec43AD184f8B',\n  tickLensAddress: '0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950',\n  swapRouter02Address: '0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE'\n};\nvar BASE_ADDRESSES = {\n  v3CoreFactoryAddress: '0x33128a8fC17869897dcE68Ed026d694621f6FDfD',\n  multicallAddress: '0x091e99cb1C49331a94dD62755D168E941AbD0693',\n  quoterAddress: '0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a',\n  v3MigratorAddress: '0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7',\n  nonfungiblePositionManagerAddress: '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1',\n  tickLensAddress: '0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d',\n  swapRouter02Address: '0x2626664c2603336E57B271c5C0b26F421741e481'\n}; // Base Goerli v3 addresses\n\nvar BASE_GOERLI_ADDRESSES = {\n  v3CoreFactoryAddress: '0x9323c1d6D800ed51Bd7C6B216cfBec678B7d0BC2',\n  multicallAddress: '0xB206027a9E0E13F05eBEFa5D2402Bab3eA716439',\n  quoterAddress: '0xedf539058e28E5937dAef3f69cEd0b25fbE66Ae9',\n  v3MigratorAddress: '0x3efe5d02a04b7351D671Db7008ec6eBA9AD9e3aE',\n  nonfungiblePositionManagerAddress: '0x3c61369ef0D1D2AFa70d8feC2F31C5D6Ce134F30',\n  tickLensAddress: '0x1acB873Ee909D0c98adB18e4474943249F931b92',\n  swapRouter02Address: '0x8357227D4eDc78991Db6FDB9bD6ADE250536dE1d'\n};\nvar CHAIN_TO_ADDRESSES_MAP = (_CHAIN_TO_ADDRESSES_M = {}, _CHAIN_TO_ADDRESSES_M[ChainId.MAINNET] = MAINNET_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM] = OPTIMISM_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_ONE] = ARBITRUM_ONE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.POLYGON] = POLYGON_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.POLYGON_MUMBAI] = POLYGON_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.GOERLI] = GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.CELO] = CELO_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.CELO_ALFAJORES] = CELO_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BNB] = BNB_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM_GOERLI] = OPTIMISM_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM_SEPOLIA] = OPTIMISM_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_GOERLI] = ARBITRUM_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.SEPOLIA] = SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.AVALANCHE] = AVALANCHE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE] = BASE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE_GOERLI] = BASE_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M);\n/* V3 Contract Addresses */\n\nvar V3_CORE_FACTORY_ADDRESSES = /*#__PURE__*/_extends({}, /*#__PURE__*/SUPPORTED_CHAINS.reduce(function (memo, chainId) {\n  memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].v3CoreFactoryAddress;\n  return memo;\n}, {}));\nvar V3_MIGRATOR_ADDRESSES = /*#__PURE__*/_extends({}, /*#__PURE__*/SUPPORTED_CHAINS.reduce(function (memo, chainId) {\n  var v3MigratorAddress = CHAIN_TO_ADDRESSES_MAP[chainId].v3MigratorAddress;\n\n  if (v3MigratorAddress) {\n    memo[chainId] = v3MigratorAddress;\n  }\n\n  return memo;\n}, {}));\nvar MULTICALL_ADDRESSES = /*#__PURE__*/_extends({}, /*#__PURE__*/SUPPORTED_CHAINS.reduce(function (memo, chainId) {\n  memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].multicallAddress;\n  return memo;\n}, {}));\n/**\r\n * The oldest V0 governance address\r\n */\n\nvar GOVERNANCE_ALPHA_V0_ADDRESSES = /*#__PURE__*/constructSameAddressMap('0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F');\n/**\r\n * The older V1 governance address\r\n */\n\nvar GOVERNANCE_ALPHA_V1_ADDRESSES = (_GOVERNANCE_ALPHA_V1_ = {}, _GOVERNANCE_ALPHA_V1_[ChainId.MAINNET] = '0xC4e172459f1E7939D522503B81AFAaC1014CE6F6', _GOVERNANCE_ALPHA_V1_);\n/**\r\n * The latest governor bravo that is currently admin of timelock\r\n */\n\nvar GOVERNANCE_BRAVO_ADDRESSES = (_GOVERNANCE_BRAVO_ADD = {}, _GOVERNANCE_BRAVO_ADD[ChainId.MAINNET] = '0x408ED6354d4973f66138C91495F2f2FCbd8724C3', _GOVERNANCE_BRAVO_ADD);\nvar TIMELOCK_ADDRESSES = /*#__PURE__*/constructSameAddressMap('0x1a9C8182C09F50C8318d769245beA52c32BE35BC');\nvar MERKLE_DISTRIBUTOR_ADDRESS = (_MERKLE_DISTRIBUTOR_A = {}, _MERKLE_DISTRIBUTOR_A[ChainId.MAINNET] = '0x090D4613473dEE047c3f2706764f49E0821D256e', _MERKLE_DISTRIBUTOR_A);\nvar ARGENT_WALLET_DETECTOR_ADDRESS = (_ARGENT_WALLET_DETECT = {}, _ARGENT_WALLET_DETECT[ChainId.MAINNET] = '0xeca4B0bDBf7c55E9b7925919d03CbF8Dc82537E8', _ARGENT_WALLET_DETECT);\nvar QUOTER_ADDRESSES = /*#__PURE__*/_extends({}, /*#__PURE__*/SUPPORTED_CHAINS.reduce(function (memo, chainId) {\n  memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].quoterAddress;\n  return memo;\n}, {}));\nvar NONFUNGIBLE_POSITION_MANAGER_ADDRESSES = /*#__PURE__*/_extends({}, /*#__PURE__*/SUPPORTED_CHAINS.reduce(function (memo, chainId) {\n  var nonfungiblePositionManagerAddress = CHAIN_TO_ADDRESSES_MAP[chainId].nonfungiblePositionManagerAddress;\n\n  if (nonfungiblePositionManagerAddress) {\n    memo[chainId] = nonfungiblePositionManagerAddress;\n  }\n\n  return memo;\n}, {}));\nvar ENS_REGISTRAR_ADDRESSES = /*#__PURE__*/_extends({}, /*#__PURE__*/constructSameAddressMap('0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'));\nvar SOCKS_CONTROLLER_ADDRESSES = (_SOCKS_CONTROLLER_ADD = {}, _SOCKS_CONTROLLER_ADD[ChainId.MAINNET] = '0x65770b5283117639760beA3F867b69b3697a91dd', _SOCKS_CONTROLLER_ADD);\nvar TICK_LENS_ADDRESSES = /*#__PURE__*/_extends({}, /*#__PURE__*/SUPPORTED_CHAINS.reduce(function (memo, chainId) {\n  var tickLensAddress = CHAIN_TO_ADDRESSES_MAP[chainId].tickLensAddress;\n\n  if (tickLensAddress) {\n    memo[chainId] = tickLensAddress;\n  }\n\n  return memo;\n}, {}));\nvar MIXED_ROUTE_QUOTER_V1_ADDRESSES = /*#__PURE__*/SUPPORTED_CHAINS.reduce(function (memo, chainId) {\n  var v1MixedRouteQuoterAddress = CHAIN_TO_ADDRESSES_MAP[chainId].v1MixedRouteQuoterAddress;\n\n  if (v1MixedRouteQuoterAddress) {\n    memo[chainId] = v1MixedRouteQuoterAddress;\n  }\n\n  return memo;\n}, {});\nvar SWAP_ROUTER_02_ADDRESSES = function SWAP_ROUTER_02_ADDRESSES(chainId) {\n  if (chainId == ChainId.BNB) {\n    return CHAIN_TO_ADDRESSES_MAP[chainId].swapRouter02Address;\n  }\n\n  return '0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45';\n};\n\nvar TradeType;\n\n(function (TradeType) {\n  TradeType[TradeType[\"EXACT_INPUT\"] = 0] = \"EXACT_INPUT\";\n  TradeType[TradeType[\"EXACT_OUTPUT\"] = 1] = \"EXACT_OUTPUT\";\n})(TradeType || (TradeType = {}));\n\nvar Rounding;\n\n(function (Rounding) {\n  Rounding[Rounding[\"ROUND_DOWN\"] = 0] = \"ROUND_DOWN\";\n  Rounding[Rounding[\"ROUND_HALF_UP\"] = 1] = \"ROUND_HALF_UP\";\n  Rounding[Rounding[\"ROUND_UP\"] = 2] = \"ROUND_UP\";\n})(Rounding || (Rounding = {}));\n\nvar MaxUint256 = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n\nvar _toSignificantRoundin, _toFixedRounding;\nvar Decimal = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(decimal_js_light__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\nvar Big = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(big_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvar toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);\nvar toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);\nvar Fraction = /*#__PURE__*/function () {\n  function Fraction(numerator, denominator) {\n    if (denominator === void 0) {\n      denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1);\n    }\n\n    this.numerator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(numerator);\n    this.denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(denominator);\n  }\n\n  Fraction.tryParseFraction = function tryParseFraction(fractionish) {\n    if (fractionish instanceof jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"] || typeof fractionish === 'number' || typeof fractionish === 'string') return new Fraction(fractionish);\n    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish;\n    throw new Error('Could not parse fraction');\n  } // performs floor division\n  ;\n\n  var _proto = Fraction.prototype;\n\n  _proto.invert = function invert() {\n    return new Fraction(this.denominator, this.numerator);\n  };\n\n  _proto.add = function add(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.numerator, otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.subtract = function subtract(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract(this.numerator, otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.lessThan = function lessThan(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.equalTo = function equalTo(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.greaterThan = function greaterThan(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.multiply = function multiply(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.numerator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.divide = function divide(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.numerator));\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n\n    !Number.isInteger(significantDigits) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, significantDigits + \" is not an integer.\") : 0 : void 0;\n    !(significantDigits > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, significantDigits + \" is not positive.\") : 0 : void 0;\n    Decimal.set({\n      precision: significantDigits + 1,\n      rounding: toSignificantRounding[rounding]\n    });\n    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);\n    return quotient.toFormat(quotient.decimalPlaces(), format);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n\n    !Number.isInteger(decimalPlaces) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, decimalPlaces + \" is not an integer.\") : 0 : void 0;\n    !(decimalPlaces >= 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, decimalPlaces + \" is negative.\") : 0 : void 0;\n    Big.DP = decimalPlaces;\n    Big.RM = toFixedRounding[rounding];\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);\n  }\n  /**\r\n   * Helper method for converting any super class back to a fraction\r\n   */\n  ;\n\n  _createClass(Fraction, [{\n    key: \"quotient\",\n    get: function get() {\n      return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(this.numerator, this.denominator);\n    } // remainder after floor division\n\n  }, {\n    key: \"remainder\",\n    get: function get() {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remainder(this.numerator, this.denominator), this.denominator);\n    }\n  }, {\n    key: \"asFraction\",\n    get: function get() {\n      return new Fraction(this.numerator, this.denominator);\n    }\n  }]);\n\n  return Fraction;\n}();\n\nvar Big$1 = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(big_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvar CurrencyAmount = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(CurrencyAmount, _Fraction);\n\n  function CurrencyAmount(currency, numerator, denominator) {\n    var _this;\n\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    !jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThanOrEqual(_this.quotient, MaxUint256) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'AMOUNT') : 0 : void 0;\n    _this.currency = currency;\n    _this.decimalScale = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(currency.decimals));\n    return _this;\n  }\n  /**\r\n   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount\r\n   * @param currency the currency in the amount\r\n   * @param rawAmount the raw token or ether amount\r\n   */\n\n\n  CurrencyAmount.fromRawAmount = function fromRawAmount(currency, rawAmount) {\n    return new CurrencyAmount(currency, rawAmount);\n  }\n  /**\r\n   * Construct a currency amount with a denominator that is not equal to 1\r\n   * @param currency the currency\r\n   * @param numerator the numerator of the fractional token amount\r\n   * @param denominator the denominator of the fractional token amount\r\n   */\n  ;\n\n  CurrencyAmount.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {\n    return new CurrencyAmount(currency, numerator, denominator);\n  };\n\n  var _proto = CurrencyAmount.prototype;\n\n  _proto.add = function add(other) {\n    !this.currency.equals(other.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CURRENCY') : 0 : void 0;\n\n    var added = _Fraction.prototype.add.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator);\n  };\n\n  _proto.subtract = function subtract(other) {\n    !this.currency.equals(other.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CURRENCY') : 0 : void 0;\n\n    var subtracted = _Fraction.prototype.subtract.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);\n  };\n\n  _proto.multiply = function multiply(other) {\n    var multiplied = _Fraction.prototype.multiply.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);\n  };\n\n  _proto.divide = function divide(other) {\n    var divided = _Fraction.prototype.divide.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n\n    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = this.currency.decimals;\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n\n    !(decimalPlaces <= this.currency.decimals) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'DECIMALS') : 0 : void 0;\n    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);\n  };\n\n  _proto.toExact = function toExact(format) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    Big$1.DP = this.currency.decimals;\n    return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);\n  };\n\n  _createClass(CurrencyAmount, [{\n    key: \"wrapped\",\n    get: function get() {\n      if (this.currency.isToken) return this;\n      return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);\n    }\n  }]);\n\n  return CurrencyAmount;\n}(Fraction);\n\nvar ONE_HUNDRED = /*#__PURE__*/new Fraction( /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(100));\n/**\r\n * Converts a fraction to a percent\r\n * @param fraction the fraction to convert\r\n */\n\nfunction toPercent(fraction) {\n  return new Percent(fraction.numerator, fraction.denominator);\n}\n\nvar Percent = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Percent, _Fraction);\n\n  function Percent() {\n    var _this;\n\n    _this = _Fraction.apply(this, arguments) || this;\n    /**\r\n     * This boolean prevents a fraction from being interpreted as a Percent\r\n     */\n\n    _this.isPercent = true;\n    return _this;\n  }\n\n  var _proto = Percent.prototype;\n\n  _proto.add = function add(other) {\n    return toPercent(_Fraction.prototype.add.call(this, other));\n  };\n\n  _proto.subtract = function subtract(other) {\n    return toPercent(_Fraction.prototype.subtract.call(this, other));\n  };\n\n  _proto.multiply = function multiply(other) {\n    return toPercent(_Fraction.prototype.multiply.call(this, other));\n  };\n\n  _proto.divide = function divide(other) {\n    return toPercent(_Fraction.prototype.divide.call(this, other));\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 5;\n    }\n\n    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 2;\n    }\n\n    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);\n  };\n\n  return Percent;\n}(Fraction);\n\nvar Price = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Price, _Fraction);\n\n  /**\r\n   * Construct a price, either with the base and quote currency amount, or the\r\n   * @param args\r\n   */\n  function Price() {\n    var _this;\n\n    var baseCurrency, quoteCurrency, denominator, numerator;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 4) {\n      baseCurrency = args[0];\n      quoteCurrency = args[1];\n      denominator = args[2];\n      numerator = args[3];\n    } else {\n      var result = args[0].quoteAmount.divide(args[0].baseAmount);\n      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];\n      baseCurrency = _ref[0];\n      quoteCurrency = _ref[1];\n      denominator = _ref[2];\n      numerator = _ref[3];\n    }\n\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    _this.baseCurrency = baseCurrency;\n    _this.quoteCurrency = quoteCurrency;\n    _this.scalar = new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(baseCurrency.decimals)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(quoteCurrency.decimals)));\n    return _this;\n  }\n  /**\r\n   * Flip the price, switching the base and quote currency\r\n   */\n\n\n  var _proto = Price.prototype;\n\n  _proto.invert = function invert() {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);\n  }\n  /**\r\n   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency\r\n   * @param other the other price\r\n   */\n  ;\n\n  _proto.multiply = function multiply(other) {\n    !this.quoteCurrency.equals(other.baseCurrency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    var fraction = _Fraction.prototype.multiply.call(this, other);\n\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);\n  }\n  /**\r\n   * Return the amount of quote currency corresponding to a given amount of the base currency\r\n   * @param currencyAmount the amount of base currency to quote against the price\r\n   */\n  ;\n\n  _proto.quote = function quote(currencyAmount) {\n    !currencyAmount.currency.equals(this.baseCurrency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    var result = _Fraction.prototype.multiply.call(this, currencyAmount);\n\n    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);\n  }\n  /**\r\n   * Get the value scaled by decimals for formatting\r\n   * @private\r\n   */\n  ;\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n\n    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 4;\n    }\n\n    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);\n  };\n\n  _createClass(Price, [{\n    key: \"adjustedForDecimals\",\n    get: function get() {\n      return _Fraction.prototype.multiply.call(this, this.scalar);\n    }\n  }]);\n\n  return Price;\n}(Fraction);\n\n/**\r\n * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies\r\n */\n\nvar BaseCurrency =\n/**\r\n * Constructs an instance of the base class `BaseCurrency`.\r\n * @param chainId the chain ID on which this currency resides\r\n * @param decimals decimals of the currency\r\n * @param symbol symbol of the currency\r\n * @param name of the currency\r\n */\nfunction BaseCurrency(chainId, decimals, symbol, name) {\n  !Number.isSafeInteger(chainId) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CHAIN_ID') : 0 : void 0;\n  !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'DECIMALS') : 0 : void 0;\n  this.chainId = chainId;\n  this.decimals = decimals;\n  this.symbol = symbol;\n  this.name = name;\n};\n\n/**\r\n * Represents the native currency of the chain on which it resides, e.g.\r\n */\n\nvar NativeCurrency = /*#__PURE__*/function (_BaseCurrency) {\n  _inheritsLoose(NativeCurrency, _BaseCurrency);\n\n  function NativeCurrency() {\n    var _this;\n\n    _this = _BaseCurrency.apply(this, arguments) || this;\n    _this.isNative = true;\n    _this.isToken = false;\n    return _this;\n  }\n\n  return NativeCurrency;\n}(BaseCurrency);\n\n/**\r\n * Validates an address and returns the parsed (checksummed) version of that address\r\n * @param address the unchecksummed hex address\r\n */\n\nfunction validateAndParseAddress(address) {\n  try {\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_5__.getAddress)(address);\n  } catch (error) {\n    throw new Error(address + \" is not a valid address.\");\n  }\n} // Checks a string starts with 0x, is 42 characters long and contains only hex characters after 0x\n\nvar startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;\n/**\r\n * Checks if an address is valid by checking 0x prefix, length === 42 and hex encoding.\r\n * @param address the unchecksummed hex address\r\n */\n\nfunction checkValidAddress(address) {\n  if (startsWith0xLen42HexRegex.test(address)) {\n    return address;\n  }\n\n  throw new Error(address + \" is not a valid address.\");\n}\n\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\n\nvar Token = /*#__PURE__*/function (_BaseCurrency) {\n  _inheritsLoose(Token, _BaseCurrency);\n\n  /**\r\n   *\r\n   * @param chainId {@link BaseCurrency#chainId}\r\n   * @param address The contract address on the chain on which this token lives\r\n   * @param decimals {@link BaseCurrency#decimals}\r\n   * @param symbol {@link BaseCurrency#symbol}\r\n   * @param name {@link BaseCurrency#name}\r\n   * @param bypassChecksum If true it only checks for length === 42, startsWith 0x and contains only hex characters\r\n   * @param buyFeeBps Buy fee tax for FOT tokens, in basis points\r\n   * @param sellFeeBps Sell fee tax for FOT tokens, in basis points\r\n   */\n  function Token(chainId, address, decimals, symbol, name, bypassChecksum, buyFeeBps, sellFeeBps) {\n    var _this;\n\n    _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;\n    _this.isNative = false;\n    _this.isToken = true;\n\n    if (bypassChecksum) {\n      _this.address = checkValidAddress(address);\n    } else {\n      _this.address = validateAndParseAddress(address);\n    }\n\n    if (buyFeeBps) {\n      !buyFeeBps.gte(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(0)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'NON-NEGATIVE FOT FEES') : 0 : void 0;\n    }\n\n    if (sellFeeBps) {\n      !sellFeeBps.gte(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(0)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'NON-NEGATIVE FOT FEES') : 0 : void 0;\n    }\n\n    _this.buyFeeBps = buyFeeBps;\n    _this.sellFeeBps = sellFeeBps;\n    return _this;\n  }\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\n\n\n  var _proto = Token.prototype;\n\n  _proto.equals = function equals(other) {\n    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();\n  }\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */\n  ;\n\n  _proto.sortsBefore = function sortsBefore(other) {\n    !(this.chainId === other.chainId) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CHAIN_IDS') : 0 : void 0;\n    !(this.address.toLowerCase() !== other.address.toLowerCase()) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'ADDRESSES') : 0 : void 0;\n    return this.address.toLowerCase() < other.address.toLowerCase();\n  }\n  /**\r\n   * Return this token, which does not need to be wrapped\r\n   */\n  ;\n\n  _createClass(Token, [{\n    key: \"wrapped\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return Token;\n}(BaseCurrency);\n\nvar _WETH;\n/**\r\n * Known WETH9 implementation addresses, used in our implementation of Ether#wrapped\r\n */\n\nvar WETH9 = (_WETH = {}, _WETH[1] = /*#__PURE__*/new Token(1, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH', 'Wrapped Ether'), _WETH[3] = /*#__PURE__*/new Token(3, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[4] = /*#__PURE__*/new Token(4, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[5] = /*#__PURE__*/new Token(5, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'), _WETH[42] = /*#__PURE__*/new Token(42, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether'), _WETH[10] = /*#__PURE__*/new Token(10, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[69] = /*#__PURE__*/new Token(69, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[11155420] = /*#__PURE__*/new Token(11155420, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[42161] = /*#__PURE__*/new Token(42161, '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1', 18, 'WETH', 'Wrapped Ether'), _WETH[421611] = /*#__PURE__*/new Token(421611, '0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681', 18, 'WETH', 'Wrapped Ether'), _WETH[8453] = /*#__PURE__*/new Token(8453, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[56] = /*#__PURE__*/new Token(56, '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', 18, 'WBNB', 'Wrapped BNB'), _WETH[137] = /*#__PURE__*/new Token(137, '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', 18, 'WMATIC', 'Wrapped MATIC'), _WETH[43114] = /*#__PURE__*/new Token(43114, '0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7', 18, 'WAVAX', 'Wrapped AVAX'), _WETH);\n\n/**\r\n * Ether is the main usage of a 'native' currency, i.e. for Ethereum mainnet and all testnets\r\n */\n\nvar Ether = /*#__PURE__*/function (_NativeCurrency) {\n  _inheritsLoose(Ether, _NativeCurrency);\n\n  function Ether(chainId) {\n    return _NativeCurrency.call(this, chainId, 18, 'ETH', 'Ether') || this;\n  }\n\n  Ether.onChain = function onChain(chainId) {\n    var _this$_etherCache$cha;\n\n    return (_this$_etherCache$cha = this._etherCache[chainId]) != null ? _this$_etherCache$cha : this._etherCache[chainId] = new Ether(chainId);\n  };\n\n  var _proto = Ether.prototype;\n\n  _proto.equals = function equals(other) {\n    return other.isNative && other.chainId === this.chainId;\n  };\n\n  _createClass(Ether, [{\n    key: \"wrapped\",\n    get: function get() {\n      var weth9 = WETH9[this.chainId];\n      !!!weth9 ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'WRAPPED') : 0 : void 0;\n      return weth9;\n    }\n  }]);\n\n  return Ether;\n}(NativeCurrency);\nEther._etherCache = {};\n\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\n\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\n  var quotedOutputAmount = midPrice.quote(inputAmount); // calculate price impact := (exactQuote - outputAmount) / exactQuote\n\n  var priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);\n  return new Percent(priceImpact.numerator, priceImpact.denominator);\n}\n\n// `maxSize` by removing the last item\n\nfunction sortedInsert(items, add, maxSize, comparator) {\n  !(maxSize > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'MAX_SIZE_ZERO') : 0 : void 0; // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n\n  !(items.length <= maxSize) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'ITEMS_SIZE') : 0 : void 0; // short circuit first item add\n\n  if (items.length === 0) {\n    items.push(add);\n    return null;\n  } else {\n    var isFull = items.length === maxSize; // short circuit if full and the additional item does not come before the last item\n\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add;\n    }\n\n    var lo = 0,\n        hi = items.length;\n\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n\n    items.splice(lo, 0, add);\n    return isFull ? items.pop() : null;\n  }\n}\n\nvar MAX_SAFE_INTEGER = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(Number.MAX_SAFE_INTEGER);\nvar ZERO = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(0);\nvar ONE = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1);\nvar TWO = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(2);\n/**\r\n * Computes floor(sqrt(value))\r\n * @param value the value for which to compute the square root, rounded down\r\n */\n\nfunction sqrt(value) {\n  !jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThanOrEqual(value, ZERO) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'NEGATIVE') : 0 : void 0; // rely on built in sqrt if possible\n\n  if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(value, MAX_SAFE_INTEGER)) {\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(Math.floor(Math.sqrt(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toNumber(value))));\n  }\n\n  var z;\n  var x;\n  z = value;\n  x = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(value, TWO), ONE);\n\n  while (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(x, z)) {\n    z = x;\n    x = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(value, x), x), TWO);\n  }\n\n  return z;\n}\n\n\n//# sourceMappingURL=sdk-core.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVuaXN3YXAvc2RrLWNvcmUvZGlzdC9zZGstY29yZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNlO0FBQ0M7QUFDZDtBQUNNO0FBQ3FCO0FBQ0Q7O0FBRXBEO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLENBQUM7O0FBRUQsK0NBQStDO0FBQy9DO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLENBQUM7O0FBRUQsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FB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Q0FBSSxtQ0FBbUMsS0FBcUMsR0FBRywwREFBUyxzQkFBc0IsQ0FBZ0IsV0FBVzs7QUFFNUksTUFBTSw0Q0FBSTtBQUNWLFdBQVcsNENBQUksNkJBQTZCLDRDQUFJO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQUksS0FBSyw0Q0FBSTs7QUFFbkIsU0FBUyw0Q0FBSTtBQUNiO0FBQ0EsUUFBUSw0Q0FBSSxRQUFRLDRDQUFJLEtBQUssNENBQUk7QUFDakM7O0FBRUE7QUFDQTs7QUFFc3pCO0FBQ3R6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BzZS0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9AdW5pc3dhcC9zZGstY29yZS9kaXN0L3Nkay1jb3JlLmVzbS5qcz9lMDlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBKU0JJIGZyb20gJ2pzYmknO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgX0RlY2ltYWwgZnJvbSAnZGVjaW1hbC5qcy1saWdodCc7XG5pbXBvcnQgX0JpZyBmcm9tICdiaWcuanMnO1xuaW1wb3J0IHRvRm9ybWF0IGZyb20gJ3RvZm9ybWF0JztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcic7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvYWRkcmVzcyc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgQ2hhaW5JZDtcblxuKGZ1bmN0aW9uIChDaGFpbklkKSB7XG4gIENoYWluSWRbQ2hhaW5JZFtcIk1BSU5ORVRcIl0gPSAxXSA9IFwiTUFJTk5FVFwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJHT0VSTElcIl0gPSA1XSA9IFwiR09FUkxJXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIlNFUE9MSUFcIl0gPSAxMTE1NTExMV0gPSBcIlNFUE9MSUFcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiT1BUSU1JU01cIl0gPSAxMF0gPSBcIk9QVElNSVNNXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIk9QVElNSVNNX0dPRVJMSVwiXSA9IDQyMF0gPSBcIk9QVElNSVNNX0dPRVJMSVwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJPUFRJTUlTTV9TRVBPTElBXCJdID0gMTExNTU0MjBdID0gXCJPUFRJTUlTTV9TRVBPTElBXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIkFSQklUUlVNX09ORVwiXSA9IDQyMTYxXSA9IFwiQVJCSVRSVU1fT05FXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIkFSQklUUlVNX0dPRVJMSVwiXSA9IDQyMTYxM10gPSBcIkFSQklUUlVNX0dPRVJMSVwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJQT0xZR09OXCJdID0gMTM3XSA9IFwiUE9MWUdPTlwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJQT0xZR09OX01VTUJBSVwiXSA9IDgwMDAxXSA9IFwiUE9MWUdPTl9NVU1CQUlcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiQ0VMT1wiXSA9IDQyMjIwXSA9IFwiQ0VMT1wiO1xuICBDaGFpbklkW0NoYWluSWRbXCJDRUxPX0FMRkFKT1JFU1wiXSA9IDQ0Nzg3XSA9IFwiQ0VMT19BTEZBSk9SRVNcIjtcbiAgQ2hhaW5JZFtDaGFpbklkW1wiR05PU0lTXCJdID0gMTAwXSA9IFwiR05PU0lTXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIk1PT05CRUFNXCJdID0gMTI4NF0gPSBcIk1PT05CRUFNXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIkJOQlwiXSA9IDU2XSA9IFwiQk5CXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIkFWQUxBTkNIRVwiXSA9IDQzMTE0XSA9IFwiQVZBTEFOQ0hFXCI7XG4gIENoYWluSWRbQ2hhaW5JZFtcIkJBU0VfR09FUkxJXCJdID0gODQ1MzFdID0gXCJCQVNFX0dPRVJMSVwiO1xuICBDaGFpbklkW0NoYWluSWRbXCJCQVNFXCJdID0gODQ1M10gPSBcIkJBU0VcIjtcbn0pKENoYWluSWQgfHwgKENoYWluSWQgPSB7fSkpO1xuXG52YXIgU1VQUE9SVEVEX0NIQUlOUyA9IFtDaGFpbklkLk1BSU5ORVQsIENoYWluSWQuT1BUSU1JU00sIENoYWluSWQuT1BUSU1JU01fR09FUkxJLCBDaGFpbklkLk9QVElNSVNNX1NFUE9MSUEsIENoYWluSWQuQVJCSVRSVU1fT05FLCBDaGFpbklkLkFSQklUUlVNX0dPRVJMSSwgQ2hhaW5JZC5QT0xZR09OLCBDaGFpbklkLlBPTFlHT05fTVVNQkFJLCBDaGFpbklkLkdPRVJMSSwgQ2hhaW5JZC5TRVBPTElBLCBDaGFpbklkLkNFTE9fQUxGQUpPUkVTLCBDaGFpbklkLkNFTE8sIENoYWluSWQuQk5CLCBDaGFpbklkLkFWQUxBTkNIRSwgQ2hhaW5JZC5CQVNFLCBDaGFpbklkLkJBU0VfR09FUkxJXTtcbnZhciBOYXRpdmVDdXJyZW5jeU5hbWU7XG5cbihmdW5jdGlvbiAoTmF0aXZlQ3VycmVuY3lOYW1lKSB7XG4gIC8vIFN0cmluZ3MgbWF0Y2ggaW5wdXQgZm9yIENMSVxuICBOYXRpdmVDdXJyZW5jeU5hbWVbXCJFVEhFUlwiXSA9IFwiRVRIXCI7XG4gIE5hdGl2ZUN1cnJlbmN5TmFtZVtcIk1BVElDXCJdID0gXCJNQVRJQ1wiO1xuICBOYXRpdmVDdXJyZW5jeU5hbWVbXCJDRUxPXCJdID0gXCJDRUxPXCI7XG4gIE5hdGl2ZUN1cnJlbmN5TmFtZVtcIkdOT1NJU1wiXSA9IFwiWERBSVwiO1xuICBOYXRpdmVDdXJyZW5jeU5hbWVbXCJNT09OQkVBTVwiXSA9IFwiR0xNUlwiO1xuICBOYXRpdmVDdXJyZW5jeU5hbWVbXCJCTkJcIl0gPSBcIkJOQlwiO1xuICBOYXRpdmVDdXJyZW5jeU5hbWVbXCJBVkFYXCJdID0gXCJBVkFYXCI7XG59KShOYXRpdmVDdXJyZW5jeU5hbWUgfHwgKE5hdGl2ZUN1cnJlbmN5TmFtZSA9IHt9KSk7XG5cbnZhciBfQ0hBSU5fVE9fQUREUkVTU0VTX00sIF9HT1ZFUk5BTkNFX0FMUEhBX1YxXywgX0dPVkVSTkFOQ0VfQlJBVk9fQURELCBfTUVSS0xFX0RJU1RSSUJVVE9SX0EsIF9BUkdFTlRfV0FMTEVUX0RFVEVDVCwgX1NPQ0tTX0NPTlRST0xMRVJfQUREO1xudmFyIERFRkFVTFRfTkVUV09SS1MgPSBbQ2hhaW5JZC5NQUlOTkVULCBDaGFpbklkLkdPRVJMSSwgQ2hhaW5JZC5TRVBPTElBXTtcblxuZnVuY3Rpb24gY29uc3RydWN0U2FtZUFkZHJlc3NNYXAoYWRkcmVzcywgYWRkaXRpb25hbE5ldHdvcmtzKSB7XG4gIGlmIChhZGRpdGlvbmFsTmV0d29ya3MgPT09IHZvaWQgMCkge1xuICAgIGFkZGl0aW9uYWxOZXR3b3JrcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIERFRkFVTFRfTkVUV09SS1MuY29uY2F0KGFkZGl0aW9uYWxOZXR3b3JrcykucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjaGFpbklkKSB7XG4gICAgbWVtb1tjaGFpbklkXSA9IGFkZHJlc3M7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbn1cblxudmFyIFVOSV9BRERSRVNTRVMgPSAvKiNfX1BVUkVfXyovY29uc3RydWN0U2FtZUFkZHJlc3NNYXAoJzB4MWY5ODQwYTg1ZDVhRjViZjFEMTc2MkY5MjVCREFEZEM0MjAxRjk4NCcsIFtDaGFpbklkLk9QVElNSVNNLCBDaGFpbklkLkFSQklUUlVNX09ORSwgQ2hhaW5JZC5QT0xZR09OLCBDaGFpbklkLlBPTFlHT05fTVVNQkFJLCBDaGFpbklkLlNFUE9MSUFdKTtcbnZhciBVTklTV0FQX05GVF9BSVJEUk9QX0NMQUlNX0FERFJFU1MgPSAnMHg4Qjc5OTM4MWFjNDBiODM4QkJBNDEzMWZmQjI2MTk3QzQzMkFGZTc4JztcbnZhciBWMl9GQUNUT1JZX0FERFJFU1MgPSAnMHg1QzY5YkVlNzAxZWY4MTRhMkI2YTNFREQ0QjE2NTJDQjljYzVhQTZmJztcbnZhciBWMl9GQUNUT1JZX0FERFJFU1NFUyA9IC8qI19fUFVSRV9fKi9jb25zdHJ1Y3RTYW1lQWRkcmVzc01hcChWMl9GQUNUT1JZX0FERFJFU1MsIFtDaGFpbklkLlBPTFlHT04sIENoYWluSWQuT1BUSU1JU00sIENoYWluSWQuQ0VMTywgQ2hhaW5JZC5BUkJJVFJVTV9PTkUsIENoYWluSWQuQk5CLCBDaGFpbklkLkFWQUxBTkNIRSwgQ2hhaW5JZC5CQVNFXSk7XG52YXIgVjJfUk9VVEVSX0FERFJFU1MgPSAnMHg3YTI1MGQ1NjMwQjRjRjUzOTczOWRGMkM1ZEFjYjRjNjU5RjI0ODhEJztcbnZhciBWMl9ST1VURVJfQUREUkVTU0VTID0gLyojX19QVVJFX18qL2NvbnN0cnVjdFNhbWVBZGRyZXNzTWFwKFYyX1JPVVRFUl9BRERSRVNTKTsgLy8gTmV0d29ya3MgdGhhdCBzaGFyZSBtb3N0IG9mIHRoZSBzYW1lIGFkZHJlc3NlcyBpLmUuIE1haW5uZXQsIEdvZXJsaSwgT3B0aW1pc20sIEFyYml0cnVtLCBQb2x5Z29uXG5cbnZhciBERUZBVUxUX0FERFJFU1NFUyA9IHtcbiAgdjNDb3JlRmFjdG9yeUFkZHJlc3M6ICcweDFGOTg0MzFjOGFEOTg1MjM2MzFBRTRhNTlmMjY3MzQ2ZWEzMUY5ODQnLFxuICBtdWx0aWNhbGxBZGRyZXNzOiAnMHgxRjk4NDE1NzU3NjIwQjU0M0E1MkU2MWM0NkIzMmVCMTkyNjFGOTg0JyxcbiAgcXVvdGVyQWRkcmVzczogJzB4YjI3MzA4ZjlGOTBENjA3NDYzYmIzM2VBMUJlQmI0MUMyN0NFNUFCNicsXG4gIHYzTWlncmF0b3JBZGRyZXNzOiAnMHhBNTY0NEUyOTcwODM1NzgwM2I1QTg4MkQyNzJjNDFjQzBkRjkyQjM0JyxcbiAgbm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJBZGRyZXNzOiAnMHhDMzY0NDJiNGE0NTIyRTg3MTM5OUNENzE3YUJERDg0N0FiMTFGRTg4J1xufTtcblxudmFyIE1BSU5ORVRfQUREUkVTU0VTID0gLyojX19QVVJFX18qL19leHRlbmRzKHt9LCBERUZBVUxUX0FERFJFU1NFUywge1xuICB2MU1peGVkUm91dGVRdW90ZXJBZGRyZXNzOiAnMHg4NEU0NDA5NWVlQmZFQzc3OTNDZDdkNWI1N0I3ZTQwMUQ3ZjFjQTJFJ1xufSk7XG5cbnZhciBHT0VSTElfQUREUkVTU0VTID0gLyojX19QVVJFX18qL19leHRlbmRzKHt9LCBERUZBVUxUX0FERFJFU1NFUywge1xuICB2MU1peGVkUm91dGVRdW90ZXJBZGRyZXNzOiAnMHhCYTYwYjZlNmZGMjU0ODgzMDg3ODlFNmUwQTY1RDgzOGJlMzQxOTRlJ1xufSk7XG5cbnZhciBPUFRJTUlTTV9BRERSRVNTRVMgPSBERUZBVUxUX0FERFJFU1NFUztcblxudmFyIEFSQklUUlVNX09ORV9BRERSRVNTRVMgPSAvKiNfX1BVUkVfXyovX2V4dGVuZHMoe30sIERFRkFVTFRfQUREUkVTU0VTLCB7XG4gIG11bHRpY2FsbEFkZHJlc3M6ICcweGFkRjg4NTk2MEI0N2VBMkNEOUI1NUU2REFjNkI0MmI3Q2IyODA2ZEInLFxuICB0aWNrTGVuc0FkZHJlc3M6ICcweGJmZDgxMzdmN2QxNTE2RDNlYTVjQTgzNTIzOTE0ODU5ZWM0N0Y1NzMnXG59KTtcblxudmFyIFBPTFlHT05fQUREUkVTU0VTID0gREVGQVVMVF9BRERSRVNTRVM7IC8vIGNlbG8gdjMgYWRkcmVzc2VzXG5cbnZhciBDRUxPX0FERFJFU1NFUyA9IHtcbiAgdjNDb3JlRmFjdG9yeUFkZHJlc3M6ICcweEFmRTIwOGEzMTFCMjFmMTNFRjg3RTMzQTkwMDQ5ZkMxN0E3YWNERWMnLFxuICBtdWx0aWNhbGxBZGRyZXNzOiAnMHg2MzM5ODc2MDJERTVDNEYzMzdlM0RiRjI2NTMwM0ExMDgwMzI0MjA0JyxcbiAgcXVvdGVyQWRkcmVzczogJzB4ODI4MjVkMDU1NGZBMDdmN0ZDNTJBYjYzYzk2MUYzMzBmZEVGYThFOCcsXG4gIHYzTWlncmF0b3JBZGRyZXNzOiAnMHgzY0ZkNGQ0OEVEZkRDQzUzRDNmMTczRjU5NmY2MjEwNjQ2MTRDNTgyJyxcbiAgbm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJBZGRyZXNzOiAnMHgzZDc5RWRBYUJDMEVhQjZGMDhFRDg4NUMwNUZjMEIwMTQyOTBEOTVBJyxcbiAgdGlja0xlbnNBZGRyZXNzOiAnMHg1ZjExNUQ5MTEzRjg4ZTBhMERiMWI1MDMzRDkwRDRhOTY5MEFjRDNEJ1xufTsgLy8gQk5CIHYzIGFkZHJlc3Nlc1xuXG52YXIgQk5CX0FERFJFU1NFUyA9IHtcbiAgdjNDb3JlRmFjdG9yeUFkZHJlc3M6ICcweGRCMWQxMDAxMUFEMEZmOTA3NzREMEM2QmI5MmU1QzVjOGI0NDYxRjcnLFxuICBtdWx0aWNhbGxBZGRyZXNzOiAnMHg5NjNEZjI0OWVEMDljMzU4QTQ4MTlFMzlkOUNkNTczNmMzMDg3MTg0JyxcbiAgcXVvdGVyQWRkcmVzczogJzB4NzhENzhFNDIwRGE5OGFkMzc4RDc3OTliRThmNEFGNjkwMzNFQjA3NycsXG4gIHYzTWlncmF0b3JBZGRyZXNzOiAnMHgzMjY4MTgxNDk1N2UwQzEzMTE3ZGRjMGMyYWJhMjMyYjVjOWU3NjBmJyxcbiAgbm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJBZGRyZXNzOiAnMHg3YjhBMDFCMzlENTgyNzhiNURFN2U0OGM4NDQ5YzlmNEY1MTcwNjEzJyxcbiAgdGlja0xlbnNBZGRyZXNzOiAnMHhEOTI3MDAxNEQzOTYyODE1Nzk3NjA2MTlDQ2Y0YzNhZjA1MDFBNDdDJyxcbiAgc3dhcFJvdXRlcjAyQWRkcmVzczogJzB4Qjk3MWVGODdlZGU1NjM1NTZiMkVENGIxQzBiMDAxOTExMURkODVkMidcbn07IC8vIG9wdGltaXNtIGdvZXJsaSBhZGRyZXNzZXNcblxudmFyIE9QVElNSVNNX0dPRVJMSV9BRERSRVNTRVMgPSB7XG4gIHYzQ29yZUZhY3RvcnlBZGRyZXNzOiAnMHhCNjU2ZEExNzEyOWU3RUI3MzNBNTU3ZjRFQmM1N0I3NkNGYkI1ZDEwJyxcbiAgbXVsdGljYWxsQWRkcmVzczogJzB4MDdGMkQ4YTJhMDIyNTFCNjJhZjk2NWYyMmZDNDc0NEE1Zjk2QkNDZCcsXG4gIHF1b3RlckFkZHJlc3M6ICcweDk1NjlDYkE5MjVjOGNhMjI0ODc3MkE5QTQ5NzZBNTE2NzQzQTI0NkYnLFxuICB2M01pZ3JhdG9yQWRkcmVzczogJzB4ZjZjNTVmQmU4NEIxQzhjMzI4MzUzM2M1M0Y1MWJDMzJGNUM3QWJhOCcsXG4gIG5vbmZ1bmdpYmxlUG9zaXRpb25NYW5hZ2VyQWRkcmVzczogJzB4MzlDYTg1QWYyRjM4MzE5MGNCZjdkN2M0MUVEOTIwMkQyNzQyNkVGNicsXG4gIHRpY2tMZW5zQWRkcmVzczogJzB4ZTYxNDBCZDE2NGI2M0U4QmZDZmM0MEQ1ZEY5NTJmODNlMTcxNzU4ZSdcbn07IC8vIG9wdGltaXNtIHNlcG9saWEgYWRkcmVzc2VzXG5cbnZhciBPUFRJTUlTTV9TRVBPTElBX0FERFJFU1NFUyA9IHtcbiAgdjNDb3JlRmFjdG9yeUFkZHJlc3M6ICcweDhDRTE5MTE5M0QxNWVhOTRlMTFkMzI3YjRjN2FkOGJiRTUyMGY2YUYnLFxuICBtdWx0aWNhbGxBZGRyZXNzOiAnMHg4MGU0ZTA2ODQxYmI3NkFBOTczNUUwNDQ4Y0I4ZDAwM0MwRUYwMDlhJyxcbiAgcXVvdGVyQWRkcmVzczogJzB4MEZCRWE2Y2Y5NTdkOTVlZTkzMTM0OTAwNTBGNkEwREE2ODAzOTQwNCcsXG4gIHYzTWlncmF0b3JBZGRyZXNzOiAnMHhFN0VjYkFBYUE1NEQwMDdBMDBkYmI2YzFkMmYxNTAwNjZENjlkQTA3JyxcbiAgbm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJBZGRyZXNzOiAnMHhkQTc1Y0VmMUM5MzA3OGU4YjczNkZDQTVENWEzMGFkYjk3Qzg5NTdkJyxcbiAgdGlja0xlbnNBZGRyZXNzOiAnMHhDYjdmNTQ3NDdGNThGODk0NDk3M2NlYTViOGY0YWMyMjA5QmFkREM1J1xufTsgLy8gYXJiaXRydW0gZ29lcmxpIHYzIGFkZHJlc3Nlc1xuXG52YXIgQVJCSVRSVU1fR09FUkxJX0FERFJFU1NFUyA9IHtcbiAgdjNDb3JlRmFjdG9yeUFkZHJlc3M6ICcweDQ4OTMzNzYzNDJkNUQ3YjNlMzFkNDE4NGMwOGIyNjVlNWFCMkEzZjYnLFxuICBtdWx0aWNhbGxBZGRyZXNzOiAnMHg4MjYwQ0I0MDI0NzI5MDMxN2E0YzA2MkYzNTQyNjIyMzY3RjIwNkVlJyxcbiAgcXVvdGVyQWRkcmVzczogJzB4MWRkOTJiODM1OTE3ODFEMEM2ZDk4ZDA3MzkxZWVhNGI5YTYwMDhGQScsXG4gIHYzTWlncmF0b3JBZGRyZXNzOiAnMHhBODE1OTE5RDI1ODRBYzNGNzZlYTlDQjYyRTZGZDQwYTQzQkNlMEMzJyxcbiAgbm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJBZGRyZXNzOiAnMHg2MjJlNDcyNmExNjc3OTk4MjZkMUUxRDE1MGIwNzZBNzcyNWY1RDgxJyxcbiAgdGlja0xlbnNBZGRyZXNzOiAnMHhiNTI0MjkzMzNkYTk2OWEwQzc5YTYwOTMwYTRCZjAwMjBFNUQxREU4J1xufTsgLy8gc2Vwb2xpYSB2MyBhZGRyZXNzZXNcblxudmFyIFNFUE9MSUFfQUREUkVTU0VTID0ge1xuICB2M0NvcmVGYWN0b3J5QWRkcmVzczogJzB4MDIyNzYyOGYzRjAyM2JiMEI5ODBiNjdENTI4NTcxYzk1YzZEYUMxYycsXG4gIG11bHRpY2FsbEFkZHJlc3M6ICcweEQ3RjMzYkNkYjIxYjM1OWM4ZWU2RjAyNTFkMzBFOTQ4MzJiYUFkMDcnLFxuICBxdW90ZXJBZGRyZXNzOiAnMHhFZDFmNjQ3MzM0NUY0NWI3NUY4MTc5NTkxZGQ1YkExODg4Y2YyRkIzJyxcbiAgdjNNaWdyYXRvckFkZHJlc3M6ICcweDcyOTAwNDE4MmNGMDA1Q0VDOEJkODVkZjE0MDA5NGI2YUNiZThiMTUnLFxuICBub25mdW5naWJsZVBvc2l0aW9uTWFuYWdlckFkZHJlc3M6ICcweDEyMzg1MzYwNzFFMWM2NzdBNjMyNDI5ZTM2NTVjNzk5YjIyY0RBNTInLFxuICB0aWNrTGVuc0FkZHJlc3M6ICcweGQ3ZjMzYmNkYjIxYjM1OWM4ZWU2ZjAyNTFkMzBlOTQ4MzJiYWFkMDcnXG59OyAvLyBBdmFsYW5jaGUgdjMgYWRkcmVzc2VzXG5cbnZhciBBVkFMQU5DSEVfQUREUkVTU0VTID0ge1xuICB2M0NvcmVGYWN0b3J5QWRkcmVzczogJzB4NzQwYjFjMWRlMjUwMzFDMzFGRjRmQzlBNjJmNTU0QTU1Y2RDMWJhRCcsXG4gIG11bHRpY2FsbEFkZHJlc3M6ICcweDAxMzkxNDFDZDRFZTg4ZEYzQ2RiNjU4ODFENDExYkFFMjcxRWYwQzInLFxuICBxdW90ZXJBZGRyZXNzOiAnMHhiZTBGNTU0NEVDNjdlOUIzYjJEOTc5YWFBNDNmMThGZDg3RTYyNTdGJyxcbiAgdjNNaWdyYXRvckFkZHJlc3M6ICcweDQ0ZjVmMWY1RTQ1MmVhOGQyOUM4OTBFOEY2ZTg5M2ZDMGYxZjBmOTcnLFxuICBub25mdW5naWJsZVBvc2l0aW9uTWFuYWdlckFkZHJlc3M6ICcweDY1NUM0MDZFQkZhMTRFRTIwMDYyNTA5MjVlNTRlYzQzQUQxODRmOEInLFxuICB0aWNrTGVuc0FkZHJlc3M6ICcweEVCOWZGQzhiZjgxYjRmRmQxMWZiNkE2M2E2QjBmMDk4YzZlMjE5NTAnLFxuICBzd2FwUm91dGVyMDJBZGRyZXNzOiAnMHhiYjAwRkYwOGQwMUQzMDAwMjNDNjI5RThmRmZGY2I2NUE1YTU3OGNFJ1xufTtcbnZhciBCQVNFX0FERFJFU1NFUyA9IHtcbiAgdjNDb3JlRmFjdG9yeUFkZHJlc3M6ICcweDMzMTI4YThmQzE3ODY5ODk3ZGNFNjhFZDAyNmQ2OTQ2MjFmNkZEZkQnLFxuICBtdWx0aWNhbGxBZGRyZXNzOiAnMHgwOTFlOTljYjFDNDkzMzFhOTRkRDYyNzU1RDE2OEU5NDFBYkQwNjkzJyxcbiAgcXVvdGVyQWRkcmVzczogJzB4M2Q0ZTQ0RWIxMzc0MjQwQ0U1RjFCODcxYWIyNjFDRDE2MzM1Qjc2YScsXG4gIHYzTWlncmF0b3JBZGRyZXNzOiAnMHgyM2NGMTBiMWVlM0FkZkNBNzNCMGVGMTdDMDdGNzU3N2U3QUNkMmQ3JyxcbiAgbm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJBZGRyZXNzOiAnMHgwM2E1MjBiMzJDMDRCRjNiRUVmN0JFYjcyRTkxOWNmODIyRWQzNGYxJyxcbiAgdGlja0xlbnNBZGRyZXNzOiAnMHgwQ2RlRTA2MWM3NUQ0M2M4MjUyMGVEOTk4QzIzYWMyOTkxYzlhYzZkJyxcbiAgc3dhcFJvdXRlcjAyQWRkcmVzczogJzB4MjYyNjY2NGMyNjAzMzM2RTU3QjI3MWM1QzBiMjZGNDIxNzQxZTQ4MSdcbn07IC8vIEJhc2UgR29lcmxpIHYzIGFkZHJlc3Nlc1xuXG52YXIgQkFTRV9HT0VSTElfQUREUkVTU0VTID0ge1xuICB2M0NvcmVGYWN0b3J5QWRkcmVzczogJzB4OTMyM2MxZDZEODAwZWQ1MUJkN0M2QjIxNmNmQmVjNjc4QjdkMEJDMicsXG4gIG11bHRpY2FsbEFkZHJlc3M6ICcweEIyMDYwMjdhOUUwRTEzRjA1ZUJFRmE1RDI0MDJCYWIzZUE3MTY0MzknLFxuICBxdW90ZXJBZGRyZXNzOiAnMHhlZGY1MzkwNThlMjhFNTkzN2RBZWYzZjY5Y0VkMGIyNWZiRTY2QWU5JyxcbiAgdjNNaWdyYXRvckFkZHJlc3M6ICcweDNlZmU1ZDAyYTA0YjczNTFENjcxRGI3MDA4ZWM2ZUJBOUFEOWUzYUUnLFxuICBub25mdW5naWJsZVBvc2l0aW9uTWFuYWdlckFkZHJlc3M6ICcweDNjNjEzNjllZjBEMUQyQUZhNzBkOGZlQzJGMzFDNUQ2Q2UxMzRGMzAnLFxuICB0aWNrTGVuc0FkZHJlc3M6ICcweDFhY0I4NzNFZTkwOUQwYzk4YWRCMThlNDQ3NDk0MzI0OUY5MzFiOTInLFxuICBzd2FwUm91dGVyMDJBZGRyZXNzOiAnMHg4MzU3MjI3RDRlRGM3ODk5MURiNkZEQjliRDZBREUyNTA1MzZkRTFkJ1xufTtcbnZhciBDSEFJTl9UT19BRERSRVNTRVNfTUFQID0gKF9DSEFJTl9UT19BRERSRVNTRVNfTSA9IHt9LCBfQ0hBSU5fVE9fQUREUkVTU0VTX01bQ2hhaW5JZC5NQUlOTkVUXSA9IE1BSU5ORVRfQUREUkVTU0VTLCBfQ0hBSU5fVE9fQUREUkVTU0VTX01bQ2hhaW5JZC5PUFRJTUlTTV0gPSBPUFRJTUlTTV9BRERSRVNTRVMsIF9DSEFJTl9UT19BRERSRVNTRVNfTVtDaGFpbklkLkFSQklUUlVNX09ORV0gPSBBUkJJVFJVTV9PTkVfQUREUkVTU0VTLCBfQ0hBSU5fVE9fQUREUkVTU0VTX01bQ2hhaW5JZC5QT0xZR09OXSA9IFBPTFlHT05fQUREUkVTU0VTLCBfQ0hBSU5fVE9fQUREUkVTU0VTX01bQ2hhaW5JZC5QT0xZR09OX01VTUJBSV0gPSBQT0xZR09OX0FERFJFU1NFUywgX0NIQUlOX1RPX0FERFJFU1NFU19NW0NoYWluSWQuR09FUkxJXSA9IEdPRVJMSV9BRERSRVNTRVMsIF9DSEFJTl9UT19BRERSRVNTRVNfTVtDaGFpbklkLkNFTE9dID0gQ0VMT19BRERSRVNTRVMsIF9DSEFJTl9UT19BRERSRVNTRVNfTVtDaGFpbklkLkNFTE9fQUxGQUpPUkVTXSA9IENFTE9fQUREUkVTU0VTLCBfQ0hBSU5fVE9fQUREUkVTU0VTX01bQ2hhaW5JZC5CTkJdID0gQk5CX0FERFJFU1NFUywgX0NIQUlOX1RPX0FERFJFU1NFU19NW0NoYWluSWQuT1BUSU1JU01fR09FUkxJXSA9IE9QVElNSVNNX0dPRVJMSV9BRERSRVNTRVMsIF9DSEFJTl9UT19BRERSRVNTRVNfTVtDaGFpbklkLk9QVElNSVNNX1NFUE9MSUFdID0gT1BUSU1JU01fU0VQT0xJQV9BRERSRVNTRVMsIF9DSEFJTl9UT19BRERSRVNTRVNfTVtDaGFpbklkLkFSQklUUlVNX0dPRVJMSV0gPSBBUkJJVFJVTV9HT0VSTElfQUREUkVTU0VTLCBfQ0hBSU5fVE9fQUREUkVTU0VTX01bQ2hhaW5JZC5TRVBPTElBXSA9IFNFUE9MSUFfQUREUkVTU0VTLCBfQ0hBSU5fVE9fQUREUkVTU0VTX01bQ2hhaW5JZC5BVkFMQU5DSEVdID0gQVZBTEFOQ0hFX0FERFJFU1NFUywgX0NIQUlOX1RPX0FERFJFU1NFU19NW0NoYWluSWQuQkFTRV0gPSBCQVNFX0FERFJFU1NFUywgX0NIQUlOX1RPX0FERFJFU1NFU19NW0NoYWluSWQuQkFTRV9HT0VSTEldID0gQkFTRV9HT0VSTElfQUREUkVTU0VTLCBfQ0hBSU5fVE9fQUREUkVTU0VTX00pO1xuLyogVjMgQ29udHJhY3QgQWRkcmVzc2VzICovXG5cbnZhciBWM19DT1JFX0ZBQ1RPUllfQUREUkVTU0VTID0gLyojX19QVVJFX18qL19leHRlbmRzKHt9LCAvKiNfX1BVUkVfXyovU1VQUE9SVEVEX0NIQUlOUy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGNoYWluSWQpIHtcbiAgbWVtb1tjaGFpbklkXSA9IENIQUlOX1RPX0FERFJFU1NFU19NQVBbY2hhaW5JZF0udjNDb3JlRmFjdG9yeUFkZHJlc3M7XG4gIHJldHVybiBtZW1vO1xufSwge30pKTtcbnZhciBWM19NSUdSQVRPUl9BRERSRVNTRVMgPSAvKiNfX1BVUkVfXyovX2V4dGVuZHMoe30sIC8qI19fUFVSRV9fKi9TVVBQT1JURURfQ0hBSU5TLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY2hhaW5JZCkge1xuICB2YXIgdjNNaWdyYXRvckFkZHJlc3MgPSBDSEFJTl9UT19BRERSRVNTRVNfTUFQW2NoYWluSWRdLnYzTWlncmF0b3JBZGRyZXNzO1xuXG4gIGlmICh2M01pZ3JhdG9yQWRkcmVzcykge1xuICAgIG1lbW9bY2hhaW5JZF0gPSB2M01pZ3JhdG9yQWRkcmVzcztcbiAgfVxuXG4gIHJldHVybiBtZW1vO1xufSwge30pKTtcbnZhciBNVUxUSUNBTExfQUREUkVTU0VTID0gLyojX19QVVJFX18qL19leHRlbmRzKHt9LCAvKiNfX1BVUkVfXyovU1VQUE9SVEVEX0NIQUlOUy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGNoYWluSWQpIHtcbiAgbWVtb1tjaGFpbklkXSA9IENIQUlOX1RPX0FERFJFU1NFU19NQVBbY2hhaW5JZF0ubXVsdGljYWxsQWRkcmVzcztcbiAgcmV0dXJuIG1lbW87XG59LCB7fSkpO1xuLyoqXHJcbiAqIFRoZSBvbGRlc3QgVjAgZ292ZXJuYW5jZSBhZGRyZXNzXHJcbiAqL1xuXG52YXIgR09WRVJOQU5DRV9BTFBIQV9WMF9BRERSRVNTRVMgPSAvKiNfX1BVUkVfXyovY29uc3RydWN0U2FtZUFkZHJlc3NNYXAoJzB4NWU0YmU4QmM5NjM3ZjBFQUExQTc1NTAxOWUwNkE2OGNlMDgxRDU4RicpO1xuLyoqXHJcbiAqIFRoZSBvbGRlciBWMSBnb3Zlcm5hbmNlIGFkZHJlc3NcclxuICovXG5cbnZhciBHT1ZFUk5BTkNFX0FMUEhBX1YxX0FERFJFU1NFUyA9IChfR09WRVJOQU5DRV9BTFBIQV9WMV8gPSB7fSwgX0dPVkVSTkFOQ0VfQUxQSEFfVjFfW0NoYWluSWQuTUFJTk5FVF0gPSAnMHhDNGUxNzI0NTlmMUU3OTM5RDUyMjUwM0I4MUFGQWFDMTAxNENFNkY2JywgX0dPVkVSTkFOQ0VfQUxQSEFfVjFfKTtcbi8qKlxyXG4gKiBUaGUgbGF0ZXN0IGdvdmVybm9yIGJyYXZvIHRoYXQgaXMgY3VycmVudGx5IGFkbWluIG9mIHRpbWVsb2NrXHJcbiAqL1xuXG52YXIgR09WRVJOQU5DRV9CUkFWT19BRERSRVNTRVMgPSAoX0dPVkVSTkFOQ0VfQlJBVk9fQUREID0ge30sIF9HT1ZFUk5BTkNFX0JSQVZPX0FERFtDaGFpbklkLk1BSU5ORVRdID0gJzB4NDA4RUQ2MzU0ZDQ5NzNmNjYxMzhDOTE0OTVGMmYyRkNiZDg3MjRDMycsIF9HT1ZFUk5BTkNFX0JSQVZPX0FERCk7XG52YXIgVElNRUxPQ0tfQUREUkVTU0VTID0gLyojX19QVVJFX18qL2NvbnN0cnVjdFNhbWVBZGRyZXNzTWFwKCcweDFhOUM4MTgyQzA5RjUwQzgzMThkNzY5MjQ1YmVBNTJjMzJCRTM1QkMnKTtcbnZhciBNRVJLTEVfRElTVFJJQlVUT1JfQUREUkVTUyA9IChfTUVSS0xFX0RJU1RSSUJVVE9SX0EgPSB7fSwgX01FUktMRV9ESVNUUklCVVRPUl9BW0NoYWluSWQuTUFJTk5FVF0gPSAnMHgwOTBENDYxMzQ3M2RFRTA0N2MzZjI3MDY3NjRmNDlFMDgyMUQyNTZlJywgX01FUktMRV9ESVNUUklCVVRPUl9BKTtcbnZhciBBUkdFTlRfV0FMTEVUX0RFVEVDVE9SX0FERFJFU1MgPSAoX0FSR0VOVF9XQUxMRVRfREVURUNUID0ge30sIF9BUkdFTlRfV0FMTEVUX0RFVEVDVFtDaGFpbklkLk1BSU5ORVRdID0gJzB4ZWNhNEIwYkRCZjdjNTVFOWI3OTI1OTE5ZDAzQ2JGOERjODI1MzdFOCcsIF9BUkdFTlRfV0FMTEVUX0RFVEVDVCk7XG52YXIgUVVPVEVSX0FERFJFU1NFUyA9IC8qI19fUFVSRV9fKi9fZXh0ZW5kcyh7fSwgLyojX19QVVJFX18qL1NVUFBPUlRFRF9DSEFJTlMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjaGFpbklkKSB7XG4gIG1lbW9bY2hhaW5JZF0gPSBDSEFJTl9UT19BRERSRVNTRVNfTUFQW2NoYWluSWRdLnF1b3RlckFkZHJlc3M7XG4gIHJldHVybiBtZW1vO1xufSwge30pKTtcbnZhciBOT05GVU5HSUJMRV9QT1NJVElPTl9NQU5BR0VSX0FERFJFU1NFUyA9IC8qI19fUFVSRV9fKi9fZXh0ZW5kcyh7fSwgLyojX19QVVJFX18qL1NVUFBPUlRFRF9DSEFJTlMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjaGFpbklkKSB7XG4gIHZhciBub25mdW5naWJsZVBvc2l0aW9uTWFuYWdlckFkZHJlc3MgPSBDSEFJTl9UT19BRERSRVNTRVNfTUFQW2NoYWluSWRdLm5vbmZ1bmdpYmxlUG9zaXRpb25NYW5hZ2VyQWRkcmVzcztcblxuICBpZiAobm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJBZGRyZXNzKSB7XG4gICAgbWVtb1tjaGFpbklkXSA9IG5vbmZ1bmdpYmxlUG9zaXRpb25NYW5hZ2VyQWRkcmVzcztcbiAgfVxuXG4gIHJldHVybiBtZW1vO1xufSwge30pKTtcbnZhciBFTlNfUkVHSVNUUkFSX0FERFJFU1NFUyA9IC8qI19fUFVSRV9fKi9fZXh0ZW5kcyh7fSwgLyojX19QVVJFX18qL2NvbnN0cnVjdFNhbWVBZGRyZXNzTWFwKCcweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWUnKSk7XG52YXIgU09DS1NfQ09OVFJPTExFUl9BRERSRVNTRVMgPSAoX1NPQ0tTX0NPTlRST0xMRVJfQUREID0ge30sIF9TT0NLU19DT05UUk9MTEVSX0FERFtDaGFpbklkLk1BSU5ORVRdID0gJzB4NjU3NzBiNTI4MzExNzYzOTc2MGJlQTNGODY3YjY5YjM2OTdhOTFkZCcsIF9TT0NLU19DT05UUk9MTEVSX0FERCk7XG52YXIgVElDS19MRU5TX0FERFJFU1NFUyA9IC8qI19fUFVSRV9fKi9fZXh0ZW5kcyh7fSwgLyojX19QVVJFX18qL1NVUFBPUlRFRF9DSEFJTlMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjaGFpbklkKSB7XG4gIHZhciB0aWNrTGVuc0FkZHJlc3MgPSBDSEFJTl9UT19BRERSRVNTRVNfTUFQW2NoYWluSWRdLnRpY2tMZW5zQWRkcmVzcztcblxuICBpZiAodGlja0xlbnNBZGRyZXNzKSB7XG4gICAgbWVtb1tjaGFpbklkXSA9IHRpY2tMZW5zQWRkcmVzcztcbiAgfVxuXG4gIHJldHVybiBtZW1vO1xufSwge30pKTtcbnZhciBNSVhFRF9ST1VURV9RVU9URVJfVjFfQUREUkVTU0VTID0gLyojX19QVVJFX18qL1NVUFBPUlRFRF9DSEFJTlMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjaGFpbklkKSB7XG4gIHZhciB2MU1peGVkUm91dGVRdW90ZXJBZGRyZXNzID0gQ0hBSU5fVE9fQUREUkVTU0VTX01BUFtjaGFpbklkXS52MU1peGVkUm91dGVRdW90ZXJBZGRyZXNzO1xuXG4gIGlmICh2MU1peGVkUm91dGVRdW90ZXJBZGRyZXNzKSB7XG4gICAgbWVtb1tjaGFpbklkXSA9IHYxTWl4ZWRSb3V0ZVF1b3RlckFkZHJlc3M7XG4gIH1cblxuICByZXR1cm4gbWVtbztcbn0sIHt9KTtcbnZhciBTV0FQX1JPVVRFUl8wMl9BRERSRVNTRVMgPSBmdW5jdGlvbiBTV0FQX1JPVVRFUl8wMl9BRERSRVNTRVMoY2hhaW5JZCkge1xuICBpZiAoY2hhaW5JZCA9PSBDaGFpbklkLkJOQikge1xuICAgIHJldHVybiBDSEFJTl9UT19BRERSRVNTRVNfTUFQW2NoYWluSWRdLnN3YXBSb3V0ZXIwMkFkZHJlc3M7XG4gIH1cblxuICByZXR1cm4gJzB4NjhiMzQ2NTgzM2ZiNzJBNzBlY0RGNDg1RTBlNEM3YkQ4NjY1RmM0NSc7XG59O1xuXG52YXIgVHJhZGVUeXBlO1xuXG4oZnVuY3Rpb24gKFRyYWRlVHlwZSkge1xuICBUcmFkZVR5cGVbVHJhZGVUeXBlW1wiRVhBQ1RfSU5QVVRcIl0gPSAwXSA9IFwiRVhBQ1RfSU5QVVRcIjtcbiAgVHJhZGVUeXBlW1RyYWRlVHlwZVtcIkVYQUNUX09VVFBVVFwiXSA9IDFdID0gXCJFWEFDVF9PVVRQVVRcIjtcbn0pKFRyYWRlVHlwZSB8fCAoVHJhZGVUeXBlID0ge30pKTtcblxudmFyIFJvdW5kaW5nO1xuXG4oZnVuY3Rpb24gKFJvdW5kaW5nKSB7XG4gIFJvdW5kaW5nW1JvdW5kaW5nW1wiUk9VTkRfRE9XTlwiXSA9IDBdID0gXCJST1VORF9ET1dOXCI7XG4gIFJvdW5kaW5nW1JvdW5kaW5nW1wiUk9VTkRfSEFMRl9VUFwiXSA9IDFdID0gXCJST1VORF9IQUxGX1VQXCI7XG4gIFJvdW5kaW5nW1JvdW5kaW5nW1wiUk9VTkRfVVBcIl0gPSAyXSA9IFwiUk9VTkRfVVBcIjtcbn0pKFJvdW5kaW5nIHx8IChSb3VuZGluZyA9IHt9KSk7XG5cbnZhciBNYXhVaW50MjU2ID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnKTtcblxudmFyIF90b1NpZ25pZmljYW50Um91bmRpbiwgX3RvRml4ZWRSb3VuZGluZztcbnZhciBEZWNpbWFsID0gLyojX19QVVJFX18qL3RvRm9ybWF0KF9EZWNpbWFsKTtcbnZhciBCaWcgPSAvKiNfX1BVUkVfXyovdG9Gb3JtYXQoX0JpZyk7XG52YXIgdG9TaWduaWZpY2FudFJvdW5kaW5nID0gKF90b1NpZ25pZmljYW50Um91bmRpbiA9IHt9LCBfdG9TaWduaWZpY2FudFJvdW5kaW5bUm91bmRpbmcuUk9VTkRfRE9XTl0gPSBEZWNpbWFsLlJPVU5EX0RPV04sIF90b1NpZ25pZmljYW50Um91bmRpbltSb3VuZGluZy5ST1VORF9IQUxGX1VQXSA9IERlY2ltYWwuUk9VTkRfSEFMRl9VUCwgX3RvU2lnbmlmaWNhbnRSb3VuZGluW1JvdW5kaW5nLlJPVU5EX1VQXSA9IERlY2ltYWwuUk9VTkRfVVAsIF90b1NpZ25pZmljYW50Um91bmRpbik7XG52YXIgdG9GaXhlZFJvdW5kaW5nID0gKF90b0ZpeGVkUm91bmRpbmcgPSB7fSwgX3RvRml4ZWRSb3VuZGluZ1tSb3VuZGluZy5ST1VORF9ET1dOXSA9IDAsIF90b0ZpeGVkUm91bmRpbmdbUm91bmRpbmcuUk9VTkRfSEFMRl9VUF0gPSAxLCBfdG9GaXhlZFJvdW5kaW5nW1JvdW5kaW5nLlJPVU5EX1VQXSA9IDMsIF90b0ZpeGVkUm91bmRpbmcpO1xudmFyIEZyYWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhY3Rpb24obnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIGlmIChkZW5vbWluYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgICBkZW5vbWluYXRvciA9IEpTQkkuQmlnSW50KDEpO1xuICAgIH1cblxuICAgIHRoaXMubnVtZXJhdG9yID0gSlNCSS5CaWdJbnQobnVtZXJhdG9yKTtcbiAgICB0aGlzLmRlbm9taW5hdG9yID0gSlNCSS5CaWdJbnQoZGVub21pbmF0b3IpO1xuICB9XG5cbiAgRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbiA9IGZ1bmN0aW9uIHRyeVBhcnNlRnJhY3Rpb24oZnJhY3Rpb25pc2gpIHtcbiAgICBpZiAoZnJhY3Rpb25pc2ggaW5zdGFuY2VvZiBKU0JJIHx8IHR5cGVvZiBmcmFjdGlvbmlzaCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGZyYWN0aW9uaXNoID09PSAnc3RyaW5nJykgcmV0dXJuIG5ldyBGcmFjdGlvbihmcmFjdGlvbmlzaCk7XG4gICAgaWYgKCdudW1lcmF0b3InIGluIGZyYWN0aW9uaXNoICYmICdkZW5vbWluYXRvcicgaW4gZnJhY3Rpb25pc2gpIHJldHVybiBmcmFjdGlvbmlzaDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBmcmFjdGlvbicpO1xuICB9IC8vIHBlcmZvcm1zIGZsb29yIGRpdmlzaW9uXG4gIDtcblxuICB2YXIgX3Byb3RvID0gRnJhY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgcmV0dXJuIG5ldyBGcmFjdGlvbih0aGlzLmRlbm9taW5hdG9yLCB0aGlzLm51bWVyYXRvcik7XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuXG4gICAgaWYgKEpTQkkuZXF1YWwodGhpcy5kZW5vbWluYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpKSB7XG4gICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkuYWRkKHRoaXMubnVtZXJhdG9yLCBvdGhlclBhcnNlZC5udW1lcmF0b3IpLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkuYWRkKEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseShvdGhlclBhcnNlZC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpKSwgSlNCSS5tdWx0aXBseSh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgdmFyIG90aGVyUGFyc2VkID0gRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbihvdGhlcik7XG5cbiAgICBpZiAoSlNCSS5lcXVhbCh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpIHtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oSlNCSS5zdWJ0cmFjdCh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQubnVtZXJhdG9yKSwgdGhpcy5kZW5vbWluYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBGcmFjdGlvbihKU0JJLnN1YnRyYWN0KEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseShvdGhlclBhcnNlZC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpKSwgSlNCSS5tdWx0aXBseSh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XG4gICAgdmFyIG90aGVyUGFyc2VkID0gRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbihvdGhlcik7XG4gICAgcmV0dXJuIEpTQkkubGVzc1RoYW4oSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpLCBKU0JJLm11bHRpcGx5KG90aGVyUGFyc2VkLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbFRvID0gZnVuY3Rpb24gZXF1YWxUbyhvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuICAgIHJldHVybiBKU0JJLmVxdWFsKEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseShvdGhlclBhcnNlZC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpKTtcbiAgfTtcblxuICBfcHJvdG8uZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuICAgIHJldHVybiBKU0JJLmdyZWF0ZXJUaGFuKEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseShvdGhlclBhcnNlZC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpKTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuICAgIHJldHVybiBuZXcgRnJhY3Rpb24oSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQubnVtZXJhdG9yKSwgSlNCSS5tdWx0aXBseSh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUob3RoZXIpIHtcbiAgICB2YXIgb3RoZXJQYXJzZWQgPSBGcmFjdGlvbi50cnlQYXJzZUZyYWN0aW9uKG90aGVyKTtcbiAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseSh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5udW1lcmF0b3IpKTtcbiAgfTtcblxuICBfcHJvdG8udG9TaWduaWZpY2FudCA9IGZ1bmN0aW9uIHRvU2lnbmlmaWNhbnQoc2lnbmlmaWNhbnREaWdpdHMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdCA9IHtcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChyb3VuZGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICByb3VuZGluZyA9IFJvdW5kaW5nLlJPVU5EX0hBTEZfVVA7XG4gICAgfVxuXG4gICAgIU51bWJlci5pc0ludGVnZXIoc2lnbmlmaWNhbnREaWdpdHMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBzaWduaWZpY2FudERpZ2l0cyArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIShzaWduaWZpY2FudERpZ2l0cyA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBzaWduaWZpY2FudERpZ2l0cyArIFwiIGlzIG5vdCBwb3NpdGl2ZS5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIERlY2ltYWwuc2V0KHtcbiAgICAgIHByZWNpc2lvbjogc2lnbmlmaWNhbnREaWdpdHMgKyAxLFxuICAgICAgcm91bmRpbmc6IHRvU2lnbmlmaWNhbnRSb3VuZGluZ1tyb3VuZGluZ11cbiAgICB9KTtcbiAgICB2YXIgcXVvdGllbnQgPSBuZXcgRGVjaW1hbCh0aGlzLm51bWVyYXRvci50b1N0cmluZygpKS5kaXYodGhpcy5kZW5vbWluYXRvci50b1N0cmluZygpKS50b1NpZ25pZmljYW50RGlnaXRzKHNpZ25pZmljYW50RGlnaXRzKTtcbiAgICByZXR1cm4gcXVvdGllbnQudG9Gb3JtYXQocXVvdGllbnQuZGVjaW1hbFBsYWNlcygpLCBmb3JtYXQpO1xuICB9O1xuXG4gIF9wcm90by50b0ZpeGVkID0gZnVuY3Rpb24gdG9GaXhlZChkZWNpbWFsUGxhY2VzLCBmb3JtYXQsIHJvdW5kaW5nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXQgPSB7XG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAocm91bmRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgcm91bmRpbmcgPSBSb3VuZGluZy5ST1VORF9IQUxGX1VQO1xuICAgIH1cblxuICAgICFOdW1iZXIuaXNJbnRlZ2VyKGRlY2ltYWxQbGFjZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBkZWNpbWFsUGxhY2VzICsgXCIgaXMgbm90IGFuIGludGVnZXIuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKGRlY2ltYWxQbGFjZXMgPj0gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGRlY2ltYWxQbGFjZXMgKyBcIiBpcyBuZWdhdGl2ZS5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIEJpZy5EUCA9IGRlY2ltYWxQbGFjZXM7XG4gICAgQmlnLlJNID0gdG9GaXhlZFJvdW5kaW5nW3JvdW5kaW5nXTtcbiAgICByZXR1cm4gbmV3IEJpZyh0aGlzLm51bWVyYXRvci50b1N0cmluZygpKS5kaXYodGhpcy5kZW5vbWluYXRvci50b1N0cmluZygpKS50b0Zvcm1hdChkZWNpbWFsUGxhY2VzLCBmb3JtYXQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEhlbHBlciBtZXRob2QgZm9yIGNvbnZlcnRpbmcgYW55IHN1cGVyIGNsYXNzIGJhY2sgdG8gYSBmcmFjdGlvblxyXG4gICAqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKEZyYWN0aW9uLCBbe1xuICAgIGtleTogXCJxdW90aWVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEpTQkkuZGl2aWRlKHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9IC8vIHJlbWFpbmRlciBhZnRlciBmbG9vciBkaXZpc2lvblxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtYWluZGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkucmVtYWluZGVyKHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKSwgdGhpcy5kZW5vbWluYXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzRnJhY3Rpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24odGhpcy5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmFjdGlvbjtcbn0oKTtcblxudmFyIEJpZyQxID0gLyojX19QVVJFX18qL3RvRm9ybWF0KF9CaWcpO1xudmFyIEN1cnJlbmN5QW1vdW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRnJhY3Rpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoQ3VycmVuY3lBbW91bnQsIF9GcmFjdGlvbik7XG5cbiAgZnVuY3Rpb24gQ3VycmVuY3lBbW91bnQoY3VycmVuY3ksIG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9GcmFjdGlvbi5jYWxsKHRoaXMsIG51bWVyYXRvciwgZGVub21pbmF0b3IpIHx8IHRoaXM7XG4gICAgIUpTQkkubGVzc1RoYW5PckVxdWFsKF90aGlzLnF1b3RpZW50LCBNYXhVaW50MjU2KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0FNT1VOVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBfdGhpcy5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgIF90aGlzLmRlY2ltYWxTY2FsZSA9IEpTQkkuZXhwb25lbnRpYXRlKEpTQkkuQmlnSW50KDEwKSwgSlNCSS5CaWdJbnQoY3VycmVuY3kuZGVjaW1hbHMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBjdXJyZW5jeSBhbW91bnQgaW5zdGFuY2UgZnJvbSB0aGUgdW5pdGxlc3MgYW1vdW50IG9mIHRva2VuLCBpLmUuIHRoZSByYXcgYW1vdW50XHJcbiAgICogQHBhcmFtIGN1cnJlbmN5IHRoZSBjdXJyZW5jeSBpbiB0aGUgYW1vdW50XHJcbiAgICogQHBhcmFtIHJhd0Ftb3VudCB0aGUgcmF3IHRva2VuIG9yIGV0aGVyIGFtb3VudFxyXG4gICAqL1xuXG5cbiAgQ3VycmVuY3lBbW91bnQuZnJvbVJhd0Ftb3VudCA9IGZ1bmN0aW9uIGZyb21SYXdBbW91bnQoY3VycmVuY3ksIHJhd0Ftb3VudCkge1xuICAgIHJldHVybiBuZXcgQ3VycmVuY3lBbW91bnQoY3VycmVuY3ksIHJhd0Ftb3VudCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgY3VycmVuY3kgYW1vdW50IHdpdGggYSBkZW5vbWluYXRvciB0aGF0IGlzIG5vdCBlcXVhbCB0byAxXHJcbiAgICogQHBhcmFtIGN1cnJlbmN5IHRoZSBjdXJyZW5jeVxyXG4gICAqIEBwYXJhbSBudW1lcmF0b3IgdGhlIG51bWVyYXRvciBvZiB0aGUgZnJhY3Rpb25hbCB0b2tlbiBhbW91bnRcclxuICAgKiBAcGFyYW0gZGVub21pbmF0b3IgdGhlIGRlbm9taW5hdG9yIG9mIHRoZSBmcmFjdGlvbmFsIHRva2VuIGFtb3VudFxyXG4gICAqL1xuICA7XG5cbiAgQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQgPSBmdW5jdGlvbiBmcm9tRnJhY3Rpb25hbEFtb3VudChjdXJyZW5jeSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIHJldHVybiBuZXcgQ3VycmVuY3lBbW91bnQoY3VycmVuY3ksIG51bWVyYXRvciwgZGVub21pbmF0b3IpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBDdXJyZW5jeUFtb3VudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChvdGhlcikge1xuICAgICF0aGlzLmN1cnJlbmN5LmVxdWFscyhvdGhlci5jdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDVVJSRU5DWScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBhZGRlZCA9IF9GcmFjdGlvbi5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgb3RoZXIpO1xuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHRoaXMuY3VycmVuY3ksIGFkZGVkLm51bWVyYXRvciwgYWRkZWQuZGVub21pbmF0b3IpO1xuICB9O1xuXG4gIF9wcm90by5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgIXRoaXMuY3VycmVuY3kuZXF1YWxzKG90aGVyLmN1cnJlbmN5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NVUlJFTkNZJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIHN1YnRyYWN0ZWQgPSBfRnJhY3Rpb24ucHJvdG90eXBlLnN1YnRyYWN0LmNhbGwodGhpcywgb3RoZXIpO1xuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHRoaXMuY3VycmVuY3ksIHN1YnRyYWN0ZWQubnVtZXJhdG9yLCBzdWJ0cmFjdGVkLmRlbm9taW5hdG9yKTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShvdGhlcikge1xuICAgIHZhciBtdWx0aXBsaWVkID0gX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIG90aGVyKTtcblxuICAgIHJldHVybiBDdXJyZW5jeUFtb3VudC5mcm9tRnJhY3Rpb25hbEFtb3VudCh0aGlzLmN1cnJlbmN5LCBtdWx0aXBsaWVkLm51bWVyYXRvciwgbXVsdGlwbGllZC5kZW5vbWluYXRvcik7XG4gIH07XG5cbiAgX3Byb3RvLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShvdGhlcikge1xuICAgIHZhciBkaXZpZGVkID0gX0ZyYWN0aW9uLnByb3RvdHlwZS5kaXZpZGUuY2FsbCh0aGlzLCBvdGhlcik7XG5cbiAgICByZXR1cm4gQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQodGhpcy5jdXJyZW5jeSwgZGl2aWRlZC5udW1lcmF0b3IsIGRpdmlkZWQuZGVub21pbmF0b3IpO1xuICB9O1xuXG4gIF9wcm90by50b1NpZ25pZmljYW50ID0gZnVuY3Rpb24gdG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDY7XG4gICAgfVxuXG4gICAgaWYgKHJvdW5kaW5nID09PSB2b2lkIDApIHtcbiAgICAgIHJvdW5kaW5nID0gUm91bmRpbmcuUk9VTkRfRE9XTjtcbiAgICB9XG5cbiAgICByZXR1cm4gX0ZyYWN0aW9uLnByb3RvdHlwZS5kaXZpZGUuY2FsbCh0aGlzLCB0aGlzLmRlY2ltYWxTY2FsZSkudG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRml4ZWQgPSBmdW5jdGlvbiB0b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZGVjaW1hbFBsYWNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWNpbWFsUGxhY2VzID0gdGhpcy5jdXJyZW5jeS5kZWNpbWFscztcbiAgICB9XG5cbiAgICBpZiAocm91bmRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgcm91bmRpbmcgPSBSb3VuZGluZy5ST1VORF9ET1dOO1xuICAgIH1cblxuICAgICEoZGVjaW1hbFBsYWNlcyA8PSB0aGlzLmN1cnJlbmN5LmRlY2ltYWxzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0RFQ0lNQUxTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBfRnJhY3Rpb24ucHJvdG90eXBlLmRpdmlkZS5jYWxsKHRoaXMsIHRoaXMuZGVjaW1hbFNjYWxlKS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpO1xuICB9O1xuXG4gIF9wcm90by50b0V4YWN0ID0gZnVuY3Rpb24gdG9FeGFjdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdCA9IHtcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIEJpZyQxLkRQID0gdGhpcy5jdXJyZW5jeS5kZWNpbWFscztcbiAgICByZXR1cm4gbmV3IEJpZyQxKHRoaXMucXVvdGllbnQudG9TdHJpbmcoKSkuZGl2KHRoaXMuZGVjaW1hbFNjYWxlLnRvU3RyaW5nKCkpLnRvRm9ybWF0KGZvcm1hdCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEN1cnJlbmN5QW1vdW50LCBbe1xuICAgIGtleTogXCJ3cmFwcGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW5jeS5pc1Rva2VuKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiBDdXJyZW5jeUFtb3VudC5mcm9tRnJhY3Rpb25hbEFtb3VudCh0aGlzLmN1cnJlbmN5LndyYXBwZWQsIHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3VycmVuY3lBbW91bnQ7XG59KEZyYWN0aW9uKTtcblxudmFyIE9ORV9IVU5EUkVEID0gLyojX19QVVJFX18qL25ldyBGcmFjdGlvbiggLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDEwMCkpO1xuLyoqXHJcbiAqIENvbnZlcnRzIGEgZnJhY3Rpb24gdG8gYSBwZXJjZW50XHJcbiAqIEBwYXJhbSBmcmFjdGlvbiB0aGUgZnJhY3Rpb24gdG8gY29udmVydFxyXG4gKi9cblxuZnVuY3Rpb24gdG9QZXJjZW50KGZyYWN0aW9uKSB7XG4gIHJldHVybiBuZXcgUGVyY2VudChmcmFjdGlvbi5udW1lcmF0b3IsIGZyYWN0aW9uLmRlbm9taW5hdG9yKTtcbn1cblxudmFyIFBlcmNlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9GcmFjdGlvbikge1xuICBfaW5oZXJpdHNMb29zZShQZXJjZW50LCBfRnJhY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIFBlcmNlbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRnJhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIC8qKlxyXG4gICAgICogVGhpcyBib29sZWFuIHByZXZlbnRzIGEgZnJhY3Rpb24gZnJvbSBiZWluZyBpbnRlcnByZXRlZCBhcyBhIFBlcmNlbnRcclxuICAgICAqL1xuXG4gICAgX3RoaXMuaXNQZXJjZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGVyY2VudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChvdGhlcikge1xuICAgIHJldHVybiB0b1BlcmNlbnQoX0ZyYWN0aW9uLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBvdGhlcikpO1xuICB9O1xuXG4gIF9wcm90by5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgcmV0dXJuIHRvUGVyY2VudChfRnJhY3Rpb24ucHJvdG90eXBlLnN1YnRyYWN0LmNhbGwodGhpcywgb3RoZXIpKTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShvdGhlcikge1xuICAgIHJldHVybiB0b1BlcmNlbnQoX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIG90aGVyKSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShvdGhlcikge1xuICAgIHJldHVybiB0b1BlcmNlbnQoX0ZyYWN0aW9uLnByb3RvdHlwZS5kaXZpZGUuY2FsbCh0aGlzLCBvdGhlcikpO1xuICB9O1xuXG4gIF9wcm90by50b1NpZ25pZmljYW50ID0gZnVuY3Rpb24gdG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9GcmFjdGlvbi5wcm90b3R5cGUubXVsdGlwbHkuY2FsbCh0aGlzLCBPTkVfSFVORFJFRCkudG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRml4ZWQgPSBmdW5jdGlvbiB0b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZGVjaW1hbFBsYWNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWNpbWFsUGxhY2VzID0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIE9ORV9IVU5EUkVEKS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpO1xuICB9O1xuXG4gIHJldHVybiBQZXJjZW50O1xufShGcmFjdGlvbik7XG5cbnZhciBQcmljZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0ZyYWN0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFByaWNlLCBfRnJhY3Rpb24pO1xuXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIHByaWNlLCBlaXRoZXIgd2l0aCB0aGUgYmFzZSBhbmQgcXVvdGUgY3VycmVuY3kgYW1vdW50LCBvciB0aGVcclxuICAgKiBAcGFyYW0gYXJnc1xyXG4gICAqL1xuICBmdW5jdGlvbiBQcmljZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgYmFzZUN1cnJlbmN5LCBxdW90ZUN1cnJlbmN5LCBkZW5vbWluYXRvciwgbnVtZXJhdG9yO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgYmFzZUN1cnJlbmN5ID0gYXJnc1swXTtcbiAgICAgIHF1b3RlQ3VycmVuY3kgPSBhcmdzWzFdO1xuICAgICAgZGVub21pbmF0b3IgPSBhcmdzWzJdO1xuICAgICAgbnVtZXJhdG9yID0gYXJnc1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3NbMF0ucXVvdGVBbW91bnQuZGl2aWRlKGFyZ3NbMF0uYmFzZUFtb3VudCk7XG4gICAgICB2YXIgX3JlZiA9IFthcmdzWzBdLmJhc2VBbW91bnQuY3VycmVuY3ksIGFyZ3NbMF0ucXVvdGVBbW91bnQuY3VycmVuY3ksIHJlc3VsdC5kZW5vbWluYXRvciwgcmVzdWx0Lm51bWVyYXRvcl07XG4gICAgICBiYXNlQ3VycmVuY3kgPSBfcmVmWzBdO1xuICAgICAgcXVvdGVDdXJyZW5jeSA9IF9yZWZbMV07XG4gICAgICBkZW5vbWluYXRvciA9IF9yZWZbMl07XG4gICAgICBudW1lcmF0b3IgPSBfcmVmWzNdO1xuICAgIH1cblxuICAgIF90aGlzID0gX0ZyYWN0aW9uLmNhbGwodGhpcywgbnVtZXJhdG9yLCBkZW5vbWluYXRvcikgfHwgdGhpcztcbiAgICBfdGhpcy5iYXNlQ3VycmVuY3kgPSBiYXNlQ3VycmVuY3k7XG4gICAgX3RoaXMucXVvdGVDdXJyZW5jeSA9IHF1b3RlQ3VycmVuY3k7XG4gICAgX3RoaXMuc2NhbGFyID0gbmV3IEZyYWN0aW9uKEpTQkkuZXhwb25lbnRpYXRlKEpTQkkuQmlnSW50KDEwKSwgSlNCSS5CaWdJbnQoYmFzZUN1cnJlbmN5LmRlY2ltYWxzKSksIEpTQkkuZXhwb25lbnRpYXRlKEpTQkkuQmlnSW50KDEwKSwgSlNCSS5CaWdJbnQocXVvdGVDdXJyZW5jeS5kZWNpbWFscykpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogRmxpcCB0aGUgcHJpY2UsIHN3aXRjaGluZyB0aGUgYmFzZSBhbmQgcXVvdGUgY3VycmVuY3lcclxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBQcmljZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmludmVydCA9IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICByZXR1cm4gbmV3IFByaWNlKHRoaXMucXVvdGVDdXJyZW5jeSwgdGhpcy5iYXNlQ3VycmVuY3ksIHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgfVxuICAvKipcclxuICAgKiBNdWx0aXBseSB0aGUgcHJpY2UgYnkgYW5vdGhlciBwcmljZSwgcmV0dXJuaW5nIGEgbmV3IHByaWNlLiBUaGUgb3RoZXIgcHJpY2UgbXVzdCBoYXZlIHRoZSBzYW1lIGJhc2UgY3VycmVuY3kgYXMgdGhpcyBwcmljZSdzIHF1b3RlIGN1cnJlbmN5XHJcbiAgICogQHBhcmFtIG90aGVyIHRoZSBvdGhlciBwcmljZVxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkob3RoZXIpIHtcbiAgICAhdGhpcy5xdW90ZUN1cnJlbmN5LmVxdWFscyhvdGhlci5iYXNlQ3VycmVuY3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVE9LRU4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgZnJhY3Rpb24gPSBfRnJhY3Rpb24ucHJvdG90eXBlLm11bHRpcGx5LmNhbGwodGhpcywgb3RoZXIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcmljZSh0aGlzLmJhc2VDdXJyZW5jeSwgb3RoZXIucXVvdGVDdXJyZW5jeSwgZnJhY3Rpb24uZGVub21pbmF0b3IsIGZyYWN0aW9uLm51bWVyYXRvcik7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBhbW91bnQgb2YgcXVvdGUgY3VycmVuY3kgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIGFtb3VudCBvZiB0aGUgYmFzZSBjdXJyZW5jeVxyXG4gICAqIEBwYXJhbSBjdXJyZW5jeUFtb3VudCB0aGUgYW1vdW50IG9mIGJhc2UgY3VycmVuY3kgdG8gcXVvdGUgYWdhaW5zdCB0aGUgcHJpY2VcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5xdW90ZSA9IGZ1bmN0aW9uIHF1b3RlKGN1cnJlbmN5QW1vdW50KSB7XG4gICAgIWN1cnJlbmN5QW1vdW50LmN1cnJlbmN5LmVxdWFscyh0aGlzLmJhc2VDdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciByZXN1bHQgPSBfRnJhY3Rpb24ucHJvdG90eXBlLm11bHRpcGx5LmNhbGwodGhpcywgY3VycmVuY3lBbW91bnQpO1xuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHRoaXMucXVvdGVDdXJyZW5jeSwgcmVzdWx0Lm51bWVyYXRvciwgcmVzdWx0LmRlbm9taW5hdG9yKTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIHZhbHVlIHNjYWxlZCBieSBkZWNpbWFscyBmb3IgZm9ybWF0dGluZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TaWduaWZpY2FudCA9IGZ1bmN0aW9uIHRvU2lnbmlmaWNhbnQoc2lnbmlmaWNhbnREaWdpdHMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgPT09IHZvaWQgMCkge1xuICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSA2O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkanVzdGVkRm9yRGVjaW1hbHMudG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRml4ZWQgPSBmdW5jdGlvbiB0b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZGVjaW1hbFBsYWNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWNpbWFsUGxhY2VzID0gNDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hZGp1c3RlZEZvckRlY2ltYWxzLnRvRml4ZWQoZGVjaW1hbFBsYWNlcywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFByaWNlLCBbe1xuICAgIGtleTogXCJhZGp1c3RlZEZvckRlY2ltYWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIHRoaXMuc2NhbGFyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJpY2U7XG59KEZyYWN0aW9uKTtcblxuLyoqXHJcbiAqIEEgY3VycmVuY3kgaXMgYW55IGZ1bmdpYmxlIGZpbmFuY2lhbCBpbnN0cnVtZW50LCBpbmNsdWRpbmcgRXRoZXIsIGFsbCBFUkMyMCB0b2tlbnMsIGFuZCBvdGhlciBjaGFpbi1uYXRpdmUgY3VycmVuY2llc1xyXG4gKi9cblxudmFyIEJhc2VDdXJyZW5jeSA9XG4vKipcclxuICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiB0aGUgYmFzZSBjbGFzcyBgQmFzZUN1cnJlbmN5YC5cclxuICogQHBhcmFtIGNoYWluSWQgdGhlIGNoYWluIElEIG9uIHdoaWNoIHRoaXMgY3VycmVuY3kgcmVzaWRlc1xyXG4gKiBAcGFyYW0gZGVjaW1hbHMgZGVjaW1hbHMgb2YgdGhlIGN1cnJlbmN5XHJcbiAqIEBwYXJhbSBzeW1ib2wgc3ltYm9sIG9mIHRoZSBjdXJyZW5jeVxyXG4gKiBAcGFyYW0gbmFtZSBvZiB0aGUgY3VycmVuY3lcclxuICovXG5mdW5jdGlvbiBCYXNlQ3VycmVuY3koY2hhaW5JZCwgZGVjaW1hbHMsIHN5bWJvbCwgbmFtZSkge1xuICAhTnVtYmVyLmlzU2FmZUludGVnZXIoY2hhaW5JZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDSEFJTl9JRCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIShkZWNpbWFscyA+PSAwICYmIGRlY2ltYWxzIDwgMjU1ICYmIE51bWJlci5pc0ludGVnZXIoZGVjaW1hbHMpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0RFQ0lNQUxTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICB0aGlzLmRlY2ltYWxzID0gZGVjaW1hbHM7XG4gIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufTtcblxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIG5hdGl2ZSBjdXJyZW5jeSBvZiB0aGUgY2hhaW4gb24gd2hpY2ggaXQgcmVzaWRlcywgZS5nLlxyXG4gKi9cblxudmFyIE5hdGl2ZUN1cnJlbmN5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUN1cnJlbmN5KSB7XG4gIF9pbmhlcml0c0xvb3NlKE5hdGl2ZUN1cnJlbmN5LCBfQmFzZUN1cnJlbmN5KTtcblxuICBmdW5jdGlvbiBOYXRpdmVDdXJyZW5jeSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlQ3VycmVuY3kuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmlzTmF0aXZlID0gdHJ1ZTtcbiAgICBfdGhpcy5pc1Rva2VuID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIE5hdGl2ZUN1cnJlbmN5O1xufShCYXNlQ3VycmVuY3kpO1xuXG4vKipcclxuICogVmFsaWRhdGVzIGFuIGFkZHJlc3MgYW5kIHJldHVybnMgdGhlIHBhcnNlZCAoY2hlY2tzdW1tZWQpIHZlcnNpb24gb2YgdGhhdCBhZGRyZXNzXHJcbiAqIEBwYXJhbSBhZGRyZXNzIHRoZSB1bmNoZWNrc3VtbWVkIGhleCBhZGRyZXNzXHJcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhhZGRyZXNzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGFkZHJlc3MgKyBcIiBpcyBub3QgYSB2YWxpZCBhZGRyZXNzLlwiKTtcbiAgfVxufSAvLyBDaGVja3MgYSBzdHJpbmcgc3RhcnRzIHdpdGggMHgsIGlzIDQyIGNoYXJhY3RlcnMgbG9uZyBhbmQgY29udGFpbnMgb25seSBoZXggY2hhcmFjdGVycyBhZnRlciAweFxuXG52YXIgc3RhcnRzV2l0aDB4TGVuNDJIZXhSZWdleCA9IC9eMHhbMC05YS1mQS1GXXs0MH0kLztcbi8qKlxyXG4gKiBDaGVja3MgaWYgYW4gYWRkcmVzcyBpcyB2YWxpZCBieSBjaGVja2luZyAweCBwcmVmaXgsIGxlbmd0aCA9PT0gNDIgYW5kIGhleCBlbmNvZGluZy5cclxuICogQHBhcmFtIGFkZHJlc3MgdGhlIHVuY2hlY2tzdW1tZWQgaGV4IGFkZHJlc3NcclxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVmFsaWRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgaWYgKHN0YXJ0c1dpdGgweExlbjQySGV4UmVnZXgudGVzdChhZGRyZXNzKSkge1xuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGFkZHJlc3MgKyBcIiBpcyBub3QgYSB2YWxpZCBhZGRyZXNzLlwiKTtcbn1cblxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gRVJDMjAgdG9rZW4gd2l0aCBhIHVuaXF1ZSBhZGRyZXNzIGFuZCBzb21lIG1ldGFkYXRhLlxyXG4gKi9cblxudmFyIFRva2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUN1cnJlbmN5KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRva2VuLCBfQmFzZUN1cnJlbmN5KTtcblxuICAvKipcclxuICAgKlxyXG4gICAqIEBwYXJhbSBjaGFpbklkIHtAbGluayBCYXNlQ3VycmVuY3kjY2hhaW5JZH1cclxuICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgY29udHJhY3QgYWRkcmVzcyBvbiB0aGUgY2hhaW4gb24gd2hpY2ggdGhpcyB0b2tlbiBsaXZlc1xyXG4gICAqIEBwYXJhbSBkZWNpbWFscyB7QGxpbmsgQmFzZUN1cnJlbmN5I2RlY2ltYWxzfVxyXG4gICAqIEBwYXJhbSBzeW1ib2wge0BsaW5rIEJhc2VDdXJyZW5jeSNzeW1ib2x9XHJcbiAgICogQHBhcmFtIG5hbWUge0BsaW5rIEJhc2VDdXJyZW5jeSNuYW1lfVxyXG4gICAqIEBwYXJhbSBieXBhc3NDaGVja3N1bSBJZiB0cnVlIGl0IG9ubHkgY2hlY2tzIGZvciBsZW5ndGggPT09IDQyLCBzdGFydHNXaXRoIDB4IGFuZCBjb250YWlucyBvbmx5IGhleCBjaGFyYWN0ZXJzXHJcbiAgICogQHBhcmFtIGJ1eUZlZUJwcyBCdXkgZmVlIHRheCBmb3IgRk9UIHRva2VucywgaW4gYmFzaXMgcG9pbnRzXHJcbiAgICogQHBhcmFtIHNlbGxGZWVCcHMgU2VsbCBmZWUgdGF4IGZvciBGT1QgdG9rZW5zLCBpbiBiYXNpcyBwb2ludHNcclxuICAgKi9cbiAgZnVuY3Rpb24gVG9rZW4oY2hhaW5JZCwgYWRkcmVzcywgZGVjaW1hbHMsIHN5bWJvbCwgbmFtZSwgYnlwYXNzQ2hlY2tzdW0sIGJ1eUZlZUJwcywgc2VsbEZlZUJwcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VDdXJyZW5jeS5jYWxsKHRoaXMsIGNoYWluSWQsIGRlY2ltYWxzLCBzeW1ib2wsIG5hbWUpIHx8IHRoaXM7XG4gICAgX3RoaXMuaXNOYXRpdmUgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1Rva2VuID0gdHJ1ZTtcblxuICAgIGlmIChieXBhc3NDaGVja3N1bSkge1xuICAgICAgX3RoaXMuYWRkcmVzcyA9IGNoZWNrVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5hZGRyZXNzID0gdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGJ1eUZlZUJwcykge1xuICAgICAgIWJ1eUZlZUJwcy5ndGUoQmlnTnVtYmVyLmZyb20oMCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTk9OLU5FR0FUSVZFIEZPVCBGRUVTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmIChzZWxsRmVlQnBzKSB7XG4gICAgICAhc2VsbEZlZUJwcy5ndGUoQmlnTnVtYmVyLmZyb20oMCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTk9OLU5FR0FUSVZFIEZPVCBGRUVTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIF90aGlzLmJ1eUZlZUJwcyA9IGJ1eUZlZUJwcztcbiAgICBfdGhpcy5zZWxsRmVlQnBzID0gc2VsbEZlZUJwcztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gdG9rZW5zIGFyZSBlcXVpdmFsZW50LCBpLmUuIGhhdmUgdGhlIHNhbWUgY2hhaW5JZCBhbmQgYWRkcmVzcy5cclxuICAgKiBAcGFyYW0gb3RoZXIgb3RoZXIgdG9rZW4gdG8gY29tcGFyZVxyXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFRva2VuLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzVG9rZW4gJiYgdGhpcy5jaGFpbklkID09PSBvdGhlci5jaGFpbklkICYmIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBvdGhlci5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIG9mIHRoaXMgdG9rZW4gc29ydHMgYmVmb3JlIHRoZSBhZGRyZXNzIG9mIHRoZSBvdGhlciB0b2tlblxyXG4gICAqIEBwYXJhbSBvdGhlciBvdGhlciB0b2tlbiB0byBjb21wYXJlXHJcbiAgICogQHRocm93cyBpZiB0aGUgdG9rZW5zIGhhdmUgdGhlIHNhbWUgYWRkcmVzc1xyXG4gICAqIEB0aHJvd3MgaWYgdGhlIHRva2VucyBhcmUgb24gZGlmZmVyZW50IGNoYWluc1xyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNvcnRzQmVmb3JlID0gZnVuY3Rpb24gc29ydHNCZWZvcmUob3RoZXIpIHtcbiAgICAhKHRoaXMuY2hhaW5JZCA9PT0gb3RoZXIuY2hhaW5JZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDSEFJTl9JRFMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gb3RoZXIuYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0FERFJFU1NFUycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPCBvdGhlci5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoaXMgdG9rZW4sIHdoaWNoIGRvZXMgbm90IG5lZWQgdG8gYmUgd3JhcHBlZFxyXG4gICAqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKFRva2VuLCBbe1xuICAgIGtleTogXCJ3cmFwcGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9rZW47XG59KEJhc2VDdXJyZW5jeSk7XG5cbnZhciBfV0VUSDtcbi8qKlxyXG4gKiBLbm93biBXRVRIOSBpbXBsZW1lbnRhdGlvbiBhZGRyZXNzZXMsIHVzZWQgaW4gb3VyIGltcGxlbWVudGF0aW9uIG9mIEV0aGVyI3dyYXBwZWRcclxuICovXG5cbnZhciBXRVRIOSA9IChfV0VUSCA9IHt9LCBfV0VUSFsxXSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oMSwgJzB4QzAyYWFBMzliMjIzRkU4RDBBMGU1QzRGMjdlQUQ5MDgzQzc1NkNjMicsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzNdID0gLyojX19QVVJFX18qL25ldyBUb2tlbigzLCAnMHhjNzc4NDE3RTA2MzE0MTEzOUZjZTAxMDk4Mjc4MDE0MEFhMGNENUFiJywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbNF0gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDQsICcweGM3Nzg0MTdFMDYzMTQxMTM5RmNlMDEwOTgyNzgwMTQwQWEwY0Q1QWInLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFs1XSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oNSwgJzB4QjRGQkYyNzExNDNGNEZCZjdCOTFBNWRlZDMxODA1ZTQyYjIyMDhkNicsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzQyXSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oNDIsICcweGQwQTFFMzU5ODExMzIyZDk3OTkxRTAzZjg2M2EwQzMwQzJjRjAyOUMnLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFsxMF0gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDEwLCAnMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2JywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbNjldID0gLyojX19QVVJFX18qL25ldyBUb2tlbig2OSwgJzB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNicsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzExMTU1NDIwXSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oMTExNTU0MjAsICcweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYnLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFs0MjE2MV0gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDQyMTYxLCAnMHg4MmFGNDk0NDdEOGEwN2UzYmQ5NUJEMGQ1NmYzNTI0MTUyM2ZCYWIxJywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbNDIxNjExXSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oNDIxNjExLCAnMHhCNDdlNkE1ZjhiMzNiM0YxNzYwM0M4M2EwNTM1QTlkY0Q3RTMyNjgxJywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbODQ1M10gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDg0NTMsICcweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYnLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFs1Nl0gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDU2LCAnMHhiYjRDZEI5Q0JkMzZCMDFiRDFjQmFFQkYyRGUwOGQ5MTczYmMwOTVjJywgMTgsICdXQk5CJywgJ1dyYXBwZWQgQk5CJyksIF9XRVRIWzEzN10gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDEzNywgJzB4MGQ1MDBCMWQ4RThlRjMxRTIxQzk5ZDFEYjlBNjQ0NGQzQURmMTI3MCcsIDE4LCAnV01BVElDJywgJ1dyYXBwZWQgTUFUSUMnKSwgX1dFVEhbNDMxMTRdID0gLyojX19QVVJFX18qL25ldyBUb2tlbig0MzExNCwgJzB4QjMxZjY2QUEzQzFlNzg1MzYzRjA4NzVBMUI3NEUyN2I4NUZENjZjNycsIDE4LCAnV0FWQVgnLCAnV3JhcHBlZCBBVkFYJyksIF9XRVRIKTtcblxuLyoqXHJcbiAqIEV0aGVyIGlzIHRoZSBtYWluIHVzYWdlIG9mIGEgJ25hdGl2ZScgY3VycmVuY3ksIGkuZS4gZm9yIEV0aGVyZXVtIG1haW5uZXQgYW5kIGFsbCB0ZXN0bmV0c1xyXG4gKi9cblxudmFyIEV0aGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTmF0aXZlQ3VycmVuY3kpIHtcbiAgX2luaGVyaXRzTG9vc2UoRXRoZXIsIF9OYXRpdmVDdXJyZW5jeSk7XG5cbiAgZnVuY3Rpb24gRXRoZXIoY2hhaW5JZCkge1xuICAgIHJldHVybiBfTmF0aXZlQ3VycmVuY3kuY2FsbCh0aGlzLCBjaGFpbklkLCAxOCwgJ0VUSCcsICdFdGhlcicpIHx8IHRoaXM7XG4gIH1cblxuICBFdGhlci5vbkNoYWluID0gZnVuY3Rpb24gb25DaGFpbihjaGFpbklkKSB7XG4gICAgdmFyIF90aGlzJF9ldGhlckNhY2hlJGNoYTtcblxuICAgIHJldHVybiAoX3RoaXMkX2V0aGVyQ2FjaGUkY2hhID0gdGhpcy5fZXRoZXJDYWNoZVtjaGFpbklkXSkgIT0gbnVsbCA/IF90aGlzJF9ldGhlckNhY2hlJGNoYSA6IHRoaXMuX2V0aGVyQ2FjaGVbY2hhaW5JZF0gPSBuZXcgRXRoZXIoY2hhaW5JZCk7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IEV0aGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzTmF0aXZlICYmIG90aGVyLmNoYWluSWQgPT09IHRoaXMuY2hhaW5JZDtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRXRoZXIsIFt7XG4gICAga2V5OiBcIndyYXBwZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciB3ZXRoOSA9IFdFVEg5W3RoaXMuY2hhaW5JZF07XG4gICAgICAhISF3ZXRoOSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1dSQVBQRUQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gd2V0aDk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV0aGVyO1xufShOYXRpdmVDdXJyZW5jeSk7XG5FdGhlci5fZXRoZXJDYWNoZSA9IHt9O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgcGVyY2VudCBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG1pZCBwcmljZSBhbmQgdGhlIGV4ZWN1dGlvbiBwcmljZSwgaS5lLiBwcmljZSBpbXBhY3QuXHJcbiAqIEBwYXJhbSBtaWRQcmljZSBtaWQgcHJpY2UgYmVmb3JlIHRoZSB0cmFkZVxyXG4gKiBAcGFyYW0gaW5wdXRBbW91bnQgdGhlIGlucHV0IGFtb3VudCBvZiB0aGUgdHJhZGVcclxuICogQHBhcmFtIG91dHB1dEFtb3VudCB0aGUgb3V0cHV0IGFtb3VudCBvZiB0aGUgdHJhZGVcclxuICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVQcmljZUltcGFjdChtaWRQcmljZSwgaW5wdXRBbW91bnQsIG91dHB1dEFtb3VudCkge1xuICB2YXIgcXVvdGVkT3V0cHV0QW1vdW50ID0gbWlkUHJpY2UucXVvdGUoaW5wdXRBbW91bnQpOyAvLyBjYWxjdWxhdGUgcHJpY2UgaW1wYWN0IDo9IChleGFjdFF1b3RlIC0gb3V0cHV0QW1vdW50KSAvIGV4YWN0UXVvdGVcblxuICB2YXIgcHJpY2VJbXBhY3QgPSBxdW90ZWRPdXRwdXRBbW91bnQuc3VidHJhY3Qob3V0cHV0QW1vdW50KS5kaXZpZGUocXVvdGVkT3V0cHV0QW1vdW50KTtcbiAgcmV0dXJuIG5ldyBQZXJjZW50KHByaWNlSW1wYWN0Lm51bWVyYXRvciwgcHJpY2VJbXBhY3QuZGVub21pbmF0b3IpO1xufVxuXG4vLyBgbWF4U2l6ZWAgYnkgcmVtb3ZpbmcgdGhlIGxhc3QgaXRlbVxuXG5mdW5jdGlvbiBzb3J0ZWRJbnNlcnQoaXRlbXMsIGFkZCwgbWF4U2l6ZSwgY29tcGFyYXRvcikge1xuICAhKG1heFNpemUgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ01BWF9TSVpFX1pFUk8nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIHRoaXMgaXMgYW4gaW52YXJpYW50IGJlY2F1c2UgdGhlIGludGVyZmFjZSBjYW5ub3QgcmV0dXJuIG11bHRpcGxlIHJlbW92ZWQgaXRlbXMgaWYgaXRlbXMubGVuZ3RoIGV4Y2VlZHMgbWF4U2l6ZVxuXG4gICEoaXRlbXMubGVuZ3RoIDw9IG1heFNpemUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSVRFTVNfU0laRScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDsgLy8gc2hvcnQgY2lyY3VpdCBmaXJzdCBpdGVtIGFkZFxuXG4gIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICBpdGVtcy5wdXNoKGFkZCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlzRnVsbCA9IGl0ZW1zLmxlbmd0aCA9PT0gbWF4U2l6ZTsgLy8gc2hvcnQgY2lyY3VpdCBpZiBmdWxsIGFuZCB0aGUgYWRkaXRpb25hbCBpdGVtIGRvZXMgbm90IGNvbWUgYmVmb3JlIHRoZSBsYXN0IGl0ZW1cblxuICAgIGlmIChpc0Z1bGwgJiYgY29tcGFyYXRvcihpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSwgYWRkKSA8PSAwKSB7XG4gICAgICByZXR1cm4gYWRkO1xuICAgIH1cblxuICAgIHZhciBsbyA9IDAsXG4gICAgICAgIGhpID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuXG4gICAgICBpZiAoY29tcGFyYXRvcihpdGVtc1ttaWRdLCBhZGQpIDw9IDApIHtcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXRlbXMuc3BsaWNlKGxvLCAwLCBhZGQpO1xuICAgIHJldHVybiBpc0Z1bGwgPyBpdGVtcy5wb3AoKSA6IG51bGw7XG4gIH1cbn1cblxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xudmFyIFpFUk8gPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoMCk7XG52YXIgT05FID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDEpO1xudmFyIFRXTyA9IC8qI19fUFVSRV9fKi9KU0JJLkJpZ0ludCgyKTtcbi8qKlxyXG4gKiBDb21wdXRlcyBmbG9vcihzcXJ0KHZhbHVlKSlcclxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgc3F1YXJlIHJvb3QsIHJvdW5kZWQgZG93blxyXG4gKi9cblxuZnVuY3Rpb24gc3FydCh2YWx1ZSkge1xuICAhSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwodmFsdWUsIFpFUk8pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTkVHQVRJVkUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIHJlbHkgb24gYnVpbHQgaW4gc3FydCBpZiBwb3NzaWJsZVxuXG4gIGlmIChKU0JJLmxlc3NUaGFuKHZhbHVlLCBNQVhfU0FGRV9JTlRFR0VSKSkge1xuICAgIHJldHVybiBKU0JJLkJpZ0ludChNYXRoLmZsb29yKE1hdGguc3FydChKU0JJLnRvTnVtYmVyKHZhbHVlKSkpKTtcbiAgfVxuXG4gIHZhciB6O1xuICB2YXIgeDtcbiAgeiA9IHZhbHVlO1xuICB4ID0gSlNCSS5hZGQoSlNCSS5kaXZpZGUodmFsdWUsIFRXTyksIE9ORSk7XG5cbiAgd2hpbGUgKEpTQkkubGVzc1RoYW4oeCwgeikpIHtcbiAgICB6ID0geDtcbiAgICB4ID0gSlNCSS5kaXZpZGUoSlNCSS5hZGQoSlNCSS5kaXZpZGUodmFsdWUsIHgpLCB4KSwgVFdPKTtcbiAgfVxuXG4gIHJldHVybiB6O1xufVxuXG5leHBvcnQgeyBBUkdFTlRfV0FMTEVUX0RFVEVDVE9SX0FERFJFU1MsIENIQUlOX1RPX0FERFJFU1NFU19NQVAsIENoYWluSWQsIEN1cnJlbmN5QW1vdW50LCBFTlNfUkVHSVNUUkFSX0FERFJFU1NFUywgRXRoZXIsIEZyYWN0aW9uLCBHT1ZFUk5BTkNFX0FMUEhBX1YwX0FERFJFU1NFUywgR09WRVJOQU5DRV9BTFBIQV9WMV9BRERSRVNTRVMsIEdPVkVSTkFOQ0VfQlJBVk9fQUREUkVTU0VTLCBNRVJLTEVfRElTVFJJQlVUT1JfQUREUkVTUywgTUlYRURfUk9VVEVfUVVPVEVSX1YxX0FERFJFU1NFUywgTVVMVElDQUxMX0FERFJFU1NFUywgTWF4VWludDI1NiwgTk9ORlVOR0lCTEVfUE9TSVRJT05fTUFOQUdFUl9BRERSRVNTRVMsIE5hdGl2ZUN1cnJlbmN5LCBOYXRpdmVDdXJyZW5jeU5hbWUsIFBlcmNlbnQsIFByaWNlLCBRVU9URVJfQUREUkVTU0VTLCBSb3VuZGluZywgU09DS1NfQ09OVFJPTExFUl9BRERSRVNTRVMsIFNVUFBPUlRFRF9DSEFJTlMsIFNXQVBfUk9VVEVSXzAyX0FERFJFU1NFUywgVElDS19MRU5TX0FERFJFU1NFUywgVElNRUxPQ0tfQUREUkVTU0VTLCBUb2tlbiwgVHJhZGVUeXBlLCBVTklTV0FQX05GVF9BSVJEUk9QX0NMQUlNX0FERFJFU1MsIFVOSV9BRERSRVNTRVMsIFYyX0ZBQ1RPUllfQUREUkVTUywgVjJfRkFDVE9SWV9BRERSRVNTRVMsIFYyX1JPVVRFUl9BRERSRVNTLCBWMl9ST1VURVJfQUREUkVTU0VTLCBWM19DT1JFX0ZBQ1RPUllfQUREUkVTU0VTLCBWM19NSUdSQVRPUl9BRERSRVNTRVMsIFdFVEg5LCBjb21wdXRlUHJpY2VJbXBhY3QsIHNvcnRlZEluc2VydCwgc3FydCwgdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNkay1jb3JlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@uniswap/v2-sdk/dist/v2-sdk.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@uniswap/v2-sdk/dist/v2-sdk.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FACTORY_ADDRESS: () => (/* binding */ FACTORY_ADDRESS),\n/* harmony export */   INIT_CODE_HASH: () => (/* binding */ INIT_CODE_HASH),\n/* harmony export */   InsufficientInputAmountError: () => (/* binding */ InsufficientInputAmountError),\n/* harmony export */   InsufficientReservesError: () => (/* binding */ InsufficientReservesError),\n/* harmony export */   MINIMUM_LIQUIDITY: () => (/* binding */ MINIMUM_LIQUIDITY),\n/* harmony export */   Pair: () => (/* binding */ Pair),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   Trade: () => (/* binding */ Trade),\n/* harmony export */   computePairAddress: () => (/* binding */ computePairAddress),\n/* harmony export */   inputOutputComparator: () => (/* binding */ inputOutputComparator),\n/* harmony export */   tradeComparator: () => (/* binding */ tradeComparator)\n/* harmony export */ });\n/* harmony import */ var jsbi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsbi */ \"(ssr)/./node_modules/jsbi/dist/jsbi.mjs\");\n/* harmony import */ var _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @uniswap/sdk-core */ \"(ssr)/./node_modules/@uniswap/v2-sdk/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/solidity */ \"(ssr)/./node_modules/@ethersproject/solidity/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\n\n\n\n\n\n\nvar FACTORY_ADDRESS = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f';\nvar INIT_CODE_HASH = '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f';\nvar MINIMUM_LIQUIDITY = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1000); // exports for internal consumption\n\nvar ZERO = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(0);\nvar ONE = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1);\nvar FIVE = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(5);\nvar _997 = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(997);\nvar _1000 = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1000);\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\n// see https://stackoverflow.com/a/41102306\nvar CAN_SET_PROTOTYPE = ('setPrototypeOf' in Object);\n/**\r\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\r\n * obtained by sending any amount of input.\r\n */\n\nvar InsufficientReservesError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(InsufficientReservesError, _Error);\n\n  function InsufficientReservesError() {\n    var _this;\n\n    _this = _Error.call(this) || this;\n    _this.isInsufficientReservesError = true;\n    _this.name = _this.constructor.name;\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof InsufficientReservesError ? this.constructor : void 0).prototype);\n    return _this;\n  }\n\n  return InsufficientReservesError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\r\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\r\n * than the price of a single unit of output after fees.\r\n */\n\nvar InsufficientInputAmountError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(InsufficientInputAmountError, _Error2);\n\n  function InsufficientInputAmountError() {\n    var _this2;\n\n    _this2 = _Error2.call(this) || this;\n    _this2.isInsufficientInputAmountError = true;\n    _this2.name = _this2.constructor.name;\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof InsufficientInputAmountError ? this.constructor : void 0).prototype);\n    return _this2;\n  }\n\n  return InsufficientInputAmountError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar computePairAddress = function computePairAddress(_ref) {\n  var factoryAddress = _ref.factoryAddress,\n      tokenA = _ref.tokenA,\n      tokenB = _ref.tokenB;\n\n  var _ref2 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],\n      token0 = _ref2[0],\n      token1 = _ref2[1]; // does safety checks\n\n\n  return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_3__.getCreate2Address)(factoryAddress, (0,_ethersproject_solidity__WEBPACK_IMPORTED_MODULE_4__.keccak256)(['bytes'], [(0,_ethersproject_solidity__WEBPACK_IMPORTED_MODULE_4__.pack)(['address', 'address'], [token0.address, token1.address])]), INIT_CODE_HASH);\n};\nvar Pair = /*#__PURE__*/function () {\n  function Pair(currencyAmountA, tokenAmountB) {\n    var tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n    ? [currencyAmountA, tokenAmountB] : [tokenAmountB, currencyAmountA];\n    this.liquidityToken = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Token(tokenAmounts[0].currency.chainId, Pair.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency), 18, 'UNI-V2', 'Uniswap V2');\n    this.tokenAmounts = tokenAmounts;\n  }\n\n  Pair.getAddress = function getAddress(tokenA, tokenB) {\n    return computePairAddress({\n      factoryAddress: FACTORY_ADDRESS,\n      tokenA: tokenA,\n      tokenB: tokenB\n    });\n  }\n  /**\r\n   * Returns true if the token is either token0 or token1\r\n   * @param token to check\r\n   */\n  ;\n\n  var _proto = Pair.prototype;\n\n  _proto.involvesToken = function involvesToken(token) {\n    return token.equals(this.token0) || token.equals(this.token1);\n  }\n  /**\r\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\r\n   */\n  ;\n\n  /**\r\n   * Return the price of the given token in terms of the other token in the pair.\r\n   * @param token token to return price of\r\n   */\n  _proto.priceOf = function priceOf(token) {\n    !this.involvesToken(token) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    return token.equals(this.token0) ? this.token0Price : this.token1Price;\n  }\n  /**\r\n   * Returns the chain ID of the tokens in the pair.\r\n   */\n  ;\n\n  _proto.reserveOf = function reserveOf(token) {\n    !this.involvesToken(token) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1;\n  };\n\n  _proto.getOutputAmount = function getOutputAmount(inputAmount) {\n    !this.involvesToken(inputAmount.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.reserve0.quotient, ZERO) || jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.reserve1.quotient, ZERO)) {\n      throw new InsufficientReservesError();\n    }\n\n    var inputReserve = this.reserveOf(inputAmount.currency);\n    var outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0);\n    var inputAmountWithFee = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(inputAmount.quotient, _997);\n    var numerator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(inputAmountWithFee, outputReserve.quotient);\n    var denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(inputReserve.quotient, _1000), inputAmountWithFee);\n    var outputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromRawAmount(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0, jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(numerator, denominator));\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(outputAmount.quotient, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  };\n\n  _proto.getInputAmount = function getInputAmount(outputAmount) {\n    !this.involvesToken(outputAmount.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.reserve0.quotient, ZERO) || jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.reserve1.quotient, ZERO) || jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient)) {\n      throw new InsufficientReservesError();\n    }\n\n    var outputReserve = this.reserveOf(outputAmount.currency);\n    var inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0);\n    var numerator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(inputReserve.quotient, outputAmount.quotient), _1000);\n    var denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract(outputReserve.quotient, outputAmount.quotient), _997);\n    var inputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromRawAmount(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0, jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(numerator, denominator), ONE));\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  };\n\n  _proto.getLiquidityMinted = function getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {\n    !totalSupply.currency.equals(this.liquidityToken) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'LIQUIDITY') : 0 : void 0;\n    var tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    !(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    var liquidity;\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(totalSupply.quotient, ZERO)) {\n      liquidity = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract((0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.sqrt)(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)), MINIMUM_LIQUIDITY);\n    } else {\n      var amount0 = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient);\n      var amount1 = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient);\n      liquidity = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThanOrEqual(amount0, amount1) ? amount0 : amount1;\n    }\n\n    if (!jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n\n    return _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity);\n  };\n\n  _proto.getLiquidityValue = function getLiquidityValue(token, totalSupply, liquidity, feeOn, kLast) {\n    if (feeOn === void 0) {\n      feeOn = false;\n    }\n\n    !this.involvesToken(token) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n    !totalSupply.currency.equals(this.liquidityToken) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TOTAL_SUPPLY') : 0 : void 0;\n    !liquidity.currency.equals(this.liquidityToken) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'LIQUIDITY') : 0 : void 0;\n    !jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThanOrEqual(liquidity.quotient, totalSupply.quotient) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'LIQUIDITY') : 0 : void 0;\n    var totalSupplyAdjusted;\n\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply;\n    } else {\n      !!!kLast ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'K_LAST') : 0 : void 0;\n      var kLastParsed = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(kLast);\n\n      if (!jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(kLastParsed, ZERO)) {\n        var rootK = (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.sqrt)(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.reserve0.quotient, this.reserve1.quotient));\n        var rootKLast = (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.sqrt)(kLastParsed);\n\n        if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThan(rootK, rootKLast)) {\n          var numerator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(totalSupply.quotient, jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract(rootK, rootKLast));\n          var denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(rootK, FIVE), rootKLast);\n          var feeLiquidity = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(numerator, denominator);\n          totalSupplyAdjusted = totalSupply.add(_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromRawAmount(this.liquidityToken, feeLiquidity));\n        } else {\n          totalSupplyAdjusted = totalSupply;\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply;\n      }\n    }\n\n    return _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromRawAmount(token, jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupplyAdjusted.quotient));\n  };\n\n  _createClass(Pair, [{\n    key: \"token0Price\",\n    get: function get() {\n      var result = this.tokenAmounts[1].divide(this.tokenAmounts[0]);\n      return new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Price(this.token0, this.token1, result.denominator, result.numerator);\n    }\n    /**\r\n     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\r\n     */\n\n  }, {\n    key: \"token1Price\",\n    get: function get() {\n      var result = this.tokenAmounts[0].divide(this.tokenAmounts[1]);\n      return new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Price(this.token1, this.token0, result.denominator, result.numerator);\n    }\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this.token0.chainId;\n    }\n  }, {\n    key: \"token0\",\n    get: function get() {\n      return this.tokenAmounts[0].currency;\n    }\n  }, {\n    key: \"token1\",\n    get: function get() {\n      return this.tokenAmounts[1].currency;\n    }\n  }, {\n    key: \"reserve0\",\n    get: function get() {\n      return this.tokenAmounts[0];\n    }\n  }, {\n    key: \"reserve1\",\n    get: function get() {\n      return this.tokenAmounts[1];\n    }\n  }]);\n\n  return Pair;\n}();\n\nvar Route = /*#__PURE__*/function () {\n  function Route(pairs, input, output) {\n    this._midPrice = null;\n    !(pairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'PAIRS') : 0 : void 0;\n    var chainId = pairs[0].chainId;\n    !pairs.every(function (pair) {\n      return pair.chainId === chainId;\n    }) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'CHAIN_IDS') : 0 : void 0;\n    var wrappedInput = input.wrapped;\n    !pairs[0].involvesToken(wrappedInput) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INPUT') : 0 : void 0;\n    !(typeof output === 'undefined' || pairs[pairs.length - 1].involvesToken(output.wrapped)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'OUTPUT') : 0 : void 0;\n    var path = [wrappedInput];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(pairs.entries()), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          i = _step$value[0],\n          pair = _step$value[1];\n      var currentInput = path[i];\n      !(currentInput.equals(pair.token0) || currentInput.equals(pair.token1)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'PATH') : 0 : void 0;\n\n      var _output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;\n\n      path.push(_output);\n    }\n\n    this.pairs = pairs;\n    this.path = path;\n    this.input = input;\n    this.output = output;\n  }\n\n  _createClass(Route, [{\n    key: \"midPrice\",\n    get: function get() {\n      if (this._midPrice !== null) return this._midPrice;\n      var prices = [];\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this.pairs.entries()), _step2; !(_step2 = _iterator2()).done;) {\n        var _step2$value = _step2.value,\n            i = _step2$value[0],\n            pair = _step2$value[1];\n        prices.push(this.path[i].equals(pair.token0) ? new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient) : new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient));\n      }\n\n      var reduced = prices.slice(1).reduce(function (accumulator, currentValue) {\n        return accumulator.multiply(currentValue);\n      }, prices[0]);\n      return this._midPrice = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Price(this.input, this.output, reduced.denominator, reduced.numerator);\n    }\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this.pairs[0].chainId;\n    }\n  }]);\n\n  return Route;\n}();\n\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\n\nfunction inputOutputComparator(a, b) {\n  // must have same input and output token for comparison\n  !a.inputAmount.currency.equals(b.inputAmount.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INPUT_CURRENCY') : 0 : void 0;\n  !a.outputAmount.currency.equals(b.outputAmount.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'OUTPUT_CURRENCY') : 0 : void 0;\n\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0;\n    } // trade A requires less input than trade B, so A should come first\n\n\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n} // extension of the input output comparator that also considers other dimensions of the trade in ranking them\n\nfunction tradeComparator(a, b) {\n  var ioComp = inputOutputComparator(a, b);\n\n  if (ioComp !== 0) {\n    return ioComp;\n  } // consider lowest slippage next, since these are less likely to fail\n\n\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1;\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1;\n  } // finally consider the number of hops since each hop costs gas\n\n\n  return a.route.path.length - b.route.path.length;\n}\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\n\nvar Trade = /*#__PURE__*/function () {\n  function Trade(route, amount, tradeType) {\n    this.route = route;\n    this.tradeType = tradeType;\n    var tokenAmounts = new Array(route.path.length);\n\n    if (tradeType === _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_INPUT) {\n      !amount.currency.equals(route.input) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INPUT') : 0 : void 0;\n      tokenAmounts[0] = amount.wrapped;\n\n      for (var i = 0; i < route.path.length - 1; i++) {\n        var pair = route.pairs[i];\n\n        var _pair$getOutputAmount = pair.getOutputAmount(tokenAmounts[i]),\n            outputAmount = _pair$getOutputAmount[0];\n\n        tokenAmounts[i + 1] = outputAmount;\n      }\n\n      this.inputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\n      this.outputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromFractionalAmount(route.output, tokenAmounts[tokenAmounts.length - 1].numerator, tokenAmounts[tokenAmounts.length - 1].denominator);\n    } else {\n      !amount.currency.equals(route.output) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'OUTPUT') : 0 : void 0;\n      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped;\n\n      for (var _i = route.path.length - 1; _i > 0; _i--) {\n        var _pair = route.pairs[_i - 1];\n\n        var _pair$getInputAmount = _pair.getInputAmount(tokenAmounts[_i]),\n            inputAmount = _pair$getInputAmount[0];\n\n        tokenAmounts[_i - 1] = inputAmount;\n      }\n\n      this.inputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromFractionalAmount(route.input, tokenAmounts[0].numerator, tokenAmounts[0].denominator);\n      this.outputAmount = _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\n    }\n\n    this.executionPrice = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n    this.priceImpact = (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.computePriceImpact)(route.midPrice, this.inputAmount, this.outputAmount);\n  }\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\n\n\n  Trade.exactIn = function exactIn(route, amountIn) {\n    return new Trade(route, amountIn, _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_INPUT);\n  }\n  /**\r\n   * Constructs an exact out trade with the given amount out and route\r\n   * @param route route of the exact out trade\r\n   * @param amountOut the amount returned by the trade\r\n   */\n  ;\n\n  Trade.exactOut = function exactOut(route, amountOut) {\n    return new Trade(route, amountOut, _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_OUTPUT);\n  }\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\n  ;\n\n  var _proto = Trade.prototype;\n\n  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance) {\n    !!slippageTolerance.lessThan(ZERO) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'SLIPPAGE_TOLERANCE') : 0 : void 0;\n\n    if (this.tradeType === _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_OUTPUT) {\n      return this.outputAmount;\n    } else {\n      var slippageAdjustedAmountOut = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Fraction(ONE).add(slippageTolerance).invert().multiply(this.outputAmount.quotient).quotient;\n      return _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);\n    }\n  }\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */\n  ;\n\n  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance) {\n    !!slippageTolerance.lessThan(ZERO) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'SLIPPAGE_TOLERANCE') : 0 : void 0;\n\n    if (this.tradeType === _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_INPUT) {\n      return this.inputAmount;\n    } else {\n      var slippageAdjustedAmountIn = new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.quotient).quotient;\n      return _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);\n    }\n  }\n  /**\r\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param nextAmountIn exact amount of input currency to spend\r\n   * @param currencyOut the desired currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\n  ;\n\n  Trade.bestTradeExactIn = function bestTradeExactIn(pairs, currencyAmountIn, currencyOut, _temp, // used in recursion.\n  currentPairs, nextAmountIn, bestTrades) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$maxNumResults = _ref.maxNumResults,\n        maxNumResults = _ref$maxNumResults === void 0 ? 3 : _ref$maxNumResults,\n        _ref$maxHops = _ref.maxHops,\n        maxHops = _ref$maxHops === void 0 ? 3 : _ref$maxHops;\n\n    if (currentPairs === void 0) {\n      currentPairs = [];\n    }\n\n    if (nextAmountIn === void 0) {\n      nextAmountIn = currencyAmountIn;\n    }\n\n    if (bestTrades === void 0) {\n      bestTrades = [];\n    }\n\n    !(pairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'PAIRS') : 0 : void 0;\n    !(maxHops > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'MAX_HOPS') : 0 : void 0;\n    !(currencyAmountIn === nextAmountIn || currentPairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INVALID_RECURSION') : 0 : void 0;\n    var amountIn = nextAmountIn.wrapped;\n    var tokenOut = currencyOut.wrapped;\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      var amountOut = void 0;\n\n      try {\n        ;\n\n        var _pair$getOutputAmount2 = pair.getOutputAmount(amountIn);\n\n        amountOut = _pair$getOutputAmount2[0];\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue;\n        }\n\n        throw error;\n      } // we have arrived at the output token, so this is the final trade of one of the paths\n\n\n      if (amountOut.currency.equals(tokenOut)) {\n        (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.sortedInsert)(bestTrades, new Trade(new Route([].concat(currentPairs, [pair]), currencyAmountIn.currency, currencyOut), currencyAmountIn, _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactIn(pairsExcludingThisPair, currencyAmountIn, currencyOut, {\n          maxNumResults: maxNumResults,\n          maxHops: maxHops - 1\n        }, [].concat(currentPairs, [pair]), amountOut, bestTrades);\n      }\n    }\n\n    return bestTrades;\n  }\n  /**\r\n   * Return the execution price after accounting for slippage tolerance\r\n   * @param slippageTolerance the allowed tolerated slippage\r\n   */\n  ;\n\n  _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {\n    return new _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\n  }\n  /**\r\n   * similar to the above method but instead targets a fixed output amount\r\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n   * to an output token amount, making at most `maxHops` hops\r\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyIn the currency to spend\r\n   * @param nextAmountOut the exact amount of currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param currencyAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */\n  ;\n\n  Trade.bestTradeExactOut = function bestTradeExactOut(pairs, currencyIn, currencyAmountOut, _temp2, // used in recursion.\n  currentPairs, nextAmountOut, bestTrades) {\n    var _ref2 = _temp2 === void 0 ? {} : _temp2,\n        _ref2$maxNumResults = _ref2.maxNumResults,\n        maxNumResults = _ref2$maxNumResults === void 0 ? 3 : _ref2$maxNumResults,\n        _ref2$maxHops = _ref2.maxHops,\n        maxHops = _ref2$maxHops === void 0 ? 3 : _ref2$maxHops;\n\n    if (currentPairs === void 0) {\n      currentPairs = [];\n    }\n\n    if (nextAmountOut === void 0) {\n      nextAmountOut = currencyAmountOut;\n    }\n\n    if (bestTrades === void 0) {\n      bestTrades = [];\n    }\n\n    !(pairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'PAIRS') : 0 : void 0;\n    !(maxHops > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'MAX_HOPS') : 0 : void 0;\n    !(currencyAmountOut === nextAmountOut || currentPairs.length > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'INVALID_RECURSION') : 0 : void 0;\n    var amountOut = nextAmountOut.wrapped;\n    var tokenIn = currencyIn.wrapped;\n\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      var amountIn = void 0;\n\n      try {\n        ;\n\n        var _pair$getInputAmount2 = pair.getInputAmount(amountOut);\n\n        amountIn = _pair$getInputAmount2[0];\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue;\n        }\n\n        throw error;\n      } // we have arrived at the input token, so this is the first trade of one of the paths\n\n\n      if (amountIn.currency.equals(tokenIn)) {\n        (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.sortedInsert)(bestTrades, new Trade(new Route([pair].concat(currentPairs), currencyIn, currencyAmountOut.currency), currencyAmountOut, _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, currencyAmountOut, {\n          maxNumResults: maxNumResults,\n          maxHops: maxHops - 1\n        }, [pair].concat(currentPairs), amountIn, bestTrades);\n      }\n    }\n\n    return bestTrades;\n  };\n\n  return Trade;\n}();\n\nfunction toHex(currencyAmount) {\n  return \"0x\" + currencyAmount.quotient.toString(16);\n}\n\nvar ZERO_HEX = '0x0';\n/**\r\n * Represents the Uniswap V2 Router, and has static methods for helping execute trades.\r\n */\n\nvar Router = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function Router() {}\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\n\n\n  Router.swapCallParameters = function swapCallParameters(trade, options) {\n    var etherIn = trade.inputAmount.currency.isNative;\n    var etherOut = trade.outputAmount.currency.isNative; // the router does not support both ether in and out\n\n    !!(etherIn && etherOut) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'ETHER_IN_OUT') : 0 : void 0;\n    !(!('ttl' in options) || options.ttl > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'TTL') : 0 : void 0;\n    var to = (0,_uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.validateAndParseAddress)(options.recipient);\n    var amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n    var amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n    var path = trade.route.path.map(function (token) {\n      return token.address;\n    });\n    var deadline = 'ttl' in options ? \"0x\" + (Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16) : \"0x\" + options.deadline.toString(16);\n    var useFeeOnTransfer = Boolean(options.feeOnTransfer);\n    var methodName;\n    var args;\n    var value;\n\n    switch (trade.tradeType) {\n      case _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'; // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        }\n\n        break;\n\n      case _uniswap_sdk_core__WEBPACK_IMPORTED_MODULE_1__.TradeType.EXACT_OUTPUT:\n        !!useFeeOnTransfer ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(false, 'EXACT_OUT_FOT') : 0 : void 0;\n\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'; // (uint amountOut, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = 'swapTokensForExactTokens'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        }\n\n        break;\n    }\n\n    return {\n      methodName: methodName,\n      args: args,\n      value: value\n    };\n  };\n\n  return Router;\n}();\n\n\n//# sourceMappingURL=v2-sdk.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVuaXN3YXAvdjItc2RrL2Rpc3QvdjItc2RrLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUMrSDtBQUNoSDtBQUNtQjtBQUNDOztBQUUzRDtBQUNBO0FBQ0EscUNBQXFDLDRDQUFJLGVBQWU7O0FBRXhELHdCQUF3Qiw0Q0FBSTtBQUM1Qix1QkFBdUIsNENBQUk7QUFDM0Isd0JBQXdCLDRDQUFJO0FBQzVCLHdCQUF3Qiw0Q0FBSTtBQUM1Qix5QkFBeUIsNENBQUk7O0FBRTdCO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx3REFBUztBQUNwQjtBQUNBLDBIQUEwSDs7QUFFMUg7QUFDQTtBQUNBLFVBQVU7QUFDViwwSEFBMEg7O0FBRTFIO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0lBQWdJOztBQUVoSTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyx3REFBUztBQUNwQiw2QkFBNkIsS0FBcUMsR0FBRywwREFBUywyQkFBMkIsQ0FBZ0I7O0FBRXpIO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBLFVBQVU7QUFDVixtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRThNO0FBQy9NIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNlLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B1bmlzd2FwL3YyLXNkay9kaXN0L3YyLXNkay5lc20uanM/MTc4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSlNCSSBmcm9tICdqc2JpJztcbmltcG9ydCB7IEN1cnJlbmN5QW1vdW50LCBzcXJ0LCBUb2tlbiwgUHJpY2UsIFRyYWRlVHlwZSwgRnJhY3Rpb24sIGNvbXB1dGVQcmljZUltcGFjdCwgc29ydGVkSW5zZXJ0LCB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyB9IGZyb20gJ0B1bmlzd2FwL3Nkay1jb3JlJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBwYWNrIH0gZnJvbSAnQGV0aGVyc3Byb2plY3Qvc29saWRpdHknO1xuaW1wb3J0IHsgZ2V0Q3JlYXRlMkFkZHJlc3MgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9hZGRyZXNzJztcblxudmFyIEZBQ1RPUllfQUREUkVTUyA9ICcweDVDNjliRWU3MDFlZjgxNGEyQjZhM0VERDRCMTY1MkNCOWNjNWFBNmYnO1xudmFyIElOSVRfQ09ERV9IQVNIID0gJzB4OTZlOGFjNDI3NzE5OGZmOGI2Zjc4NTQ3OGFhOWEzOWY0MDNjYjc2OGRkMDJjYmVlMzI2YzNlN2RhMzQ4ODQ1Zic7XG52YXIgTUlOSU1VTV9MSVFVSURJVFkgPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoMTAwMCk7IC8vIGV4cG9ydHMgZm9yIGludGVybmFsIGNvbnN1bXB0aW9uXG5cbnZhciBaRVJPID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDApO1xudmFyIE9ORSA9IC8qI19fUFVSRV9fKi9KU0JJLkJpZ0ludCgxKTtcbnZhciBGSVZFID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDUpO1xudmFyIF85OTcgPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoOTk3KTtcbnZhciBfMTAwMCA9IC8qI19fUFVSRV9fKi9KU0JJLkJpZ0ludCgxMDAwKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIGl0Lm5leHQuYmluZChpdCk7XG59XG5cbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDExMDIzMDZcbnZhciBDQU5fU0VUX1BST1RPVFlQRSA9ICgnc2V0UHJvdG90eXBlT2YnIGluIE9iamVjdCk7XG4vKipcclxuICogSW5kaWNhdGVzIHRoYXQgdGhlIHBhaXIgaGFzIGluc3VmZmljaWVudCByZXNlcnZlcyBmb3IgYSBkZXNpcmVkIG91dHB1dCBhbW91bnQuIEkuZS4gdGhlIGFtb3VudCBvZiBvdXRwdXQgY2Fubm90IGJlXHJcbiAqIG9idGFpbmVkIGJ5IHNlbmRpbmcgYW55IGFtb3VudCBvZiBpbnB1dC5cclxuICovXG5cbnZhciBJbnN1ZmZpY2llbnRSZXNlcnZlc0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5zdWZmaWNpZW50UmVzZXJ2ZXNFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBJbnN1ZmZpY2llbnRSZXNlcnZlc0Vycm9yKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Vycm9yLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5pc0luc3VmZmljaWVudFJlc2VydmVzRXJyb3IgPSB0cnVlO1xuICAgIF90aGlzLm5hbWUgPSBfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChDQU5fU0VUX1BST1RPVFlQRSkgT2JqZWN0LnNldFByb3RvdHlwZU9mKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAodGhpcyBpbnN0YW5jZW9mIEluc3VmZmljaWVudFJlc2VydmVzRXJyb3IgPyB0aGlzLmNvbnN0cnVjdG9yIDogdm9pZCAwKS5wcm90b3R5cGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbnN1ZmZpY2llbnRSZXNlcnZlc0Vycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbi8qKlxyXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgaW5wdXQgYW1vdW50IGlzIHRvbyBzbWFsbCB0byBwcm9kdWNlIGFueSBhbW91bnQgb2Ygb3V0cHV0LiBJLmUuIHRoZSBhbW91bnQgb2YgaW5wdXQgc2VudCBpcyBsZXNzXHJcbiAqIHRoYW4gdGhlIHByaWNlIG9mIGEgc2luZ2xlIHVuaXQgb2Ygb3V0cHV0IGFmdGVyIGZlZXMuXHJcbiAqL1xuXG52YXIgSW5zdWZmaWNpZW50SW5wdXRBbW91bnRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yMikge1xuICBfaW5oZXJpdHNMb29zZShJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yLCBfRXJyb3IyKTtcblxuICBmdW5jdGlvbiBJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yKCkge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfdGhpczIgPSBfRXJyb3IyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpczIuaXNJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yID0gdHJ1ZTtcbiAgICBfdGhpczIubmFtZSA9IF90aGlzMi5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChDQU5fU0VUX1BST1RPVFlQRSkgT2JqZWN0LnNldFByb3RvdHlwZU9mKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyKSwgKHRoaXMgaW5zdGFuY2VvZiBJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yID8gdGhpcy5jb25zdHJ1Y3RvciA6IHZvaWQgMCkucHJvdG90eXBlKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuIEluc3VmZmljaWVudElucHV0QW1vdW50RXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG52YXIgY29tcHV0ZVBhaXJBZGRyZXNzID0gZnVuY3Rpb24gY29tcHV0ZVBhaXJBZGRyZXNzKF9yZWYpIHtcbiAgdmFyIGZhY3RvcnlBZGRyZXNzID0gX3JlZi5mYWN0b3J5QWRkcmVzcyxcbiAgICAgIHRva2VuQSA9IF9yZWYudG9rZW5BLFxuICAgICAgdG9rZW5CID0gX3JlZi50b2tlbkI7XG5cbiAgdmFyIF9yZWYyID0gdG9rZW5BLnNvcnRzQmVmb3JlKHRva2VuQikgPyBbdG9rZW5BLCB0b2tlbkJdIDogW3Rva2VuQiwgdG9rZW5BXSxcbiAgICAgIHRva2VuMCA9IF9yZWYyWzBdLFxuICAgICAgdG9rZW4xID0gX3JlZjJbMV07IC8vIGRvZXMgc2FmZXR5IGNoZWNrc1xuXG5cbiAgcmV0dXJuIGdldENyZWF0ZTJBZGRyZXNzKGZhY3RvcnlBZGRyZXNzLCBrZWNjYWsyNTYoWydieXRlcyddLCBbcGFjayhbJ2FkZHJlc3MnLCAnYWRkcmVzcyddLCBbdG9rZW4wLmFkZHJlc3MsIHRva2VuMS5hZGRyZXNzXSldKSwgSU5JVF9DT0RFX0hBU0gpO1xufTtcbnZhciBQYWlyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFpcihjdXJyZW5jeUFtb3VudEEsIHRva2VuQW1vdW50Qikge1xuICAgIHZhciB0b2tlbkFtb3VudHMgPSBjdXJyZW5jeUFtb3VudEEuY3VycmVuY3kuc29ydHNCZWZvcmUodG9rZW5BbW91bnRCLmN1cnJlbmN5KSAvLyBkb2VzIHNhZmV0eSBjaGVja3NcbiAgICA/IFtjdXJyZW5jeUFtb3VudEEsIHRva2VuQW1vdW50Ql0gOiBbdG9rZW5BbW91bnRCLCBjdXJyZW5jeUFtb3VudEFdO1xuICAgIHRoaXMubGlxdWlkaXR5VG9rZW4gPSBuZXcgVG9rZW4odG9rZW5BbW91bnRzWzBdLmN1cnJlbmN5LmNoYWluSWQsIFBhaXIuZ2V0QWRkcmVzcyh0b2tlbkFtb3VudHNbMF0uY3VycmVuY3ksIHRva2VuQW1vdW50c1sxXS5jdXJyZW5jeSksIDE4LCAnVU5JLVYyJywgJ1VuaXN3YXAgVjInKTtcbiAgICB0aGlzLnRva2VuQW1vdW50cyA9IHRva2VuQW1vdW50cztcbiAgfVxuXG4gIFBhaXIuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uIGdldEFkZHJlc3ModG9rZW5BLCB0b2tlbkIpIHtcbiAgICByZXR1cm4gY29tcHV0ZVBhaXJBZGRyZXNzKHtcbiAgICAgIGZhY3RvcnlBZGRyZXNzOiBGQUNUT1JZX0FERFJFU1MsXG4gICAgICB0b2tlbkE6IHRva2VuQSxcbiAgICAgIHRva2VuQjogdG9rZW5CXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0b2tlbiBpcyBlaXRoZXIgdG9rZW4wIG9yIHRva2VuMVxyXG4gICAqIEBwYXJhbSB0b2tlbiB0byBjaGVja1xyXG4gICAqL1xuICA7XG5cbiAgdmFyIF9wcm90byA9IFBhaXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbnZvbHZlc1Rva2VuID0gZnVuY3Rpb24gaW52b2x2ZXNUb2tlbih0b2tlbikge1xuICAgIHJldHVybiB0b2tlbi5lcXVhbHModGhpcy50b2tlbjApIHx8IHRva2VuLmVxdWFscyh0aGlzLnRva2VuMSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBtaWQgcHJpY2Ugb2YgdGhlIHBhaXIgaW4gdGVybXMgb2YgdG9rZW4wLCBpLmUuIHRoZSByYXRpbyBvZiByZXNlcnZlMSB0byByZXNlcnZlMFxyXG4gICAqL1xuICA7XG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBwcmljZSBvZiB0aGUgZ2l2ZW4gdG9rZW4gaW4gdGVybXMgb2YgdGhlIG90aGVyIHRva2VuIGluIHRoZSBwYWlyLlxyXG4gICAqIEBwYXJhbSB0b2tlbiB0b2tlbiB0byByZXR1cm4gcHJpY2Ugb2ZcclxuICAgKi9cbiAgX3Byb3RvLnByaWNlT2YgPSBmdW5jdGlvbiBwcmljZU9mKHRva2VuKSB7XG4gICAgIXRoaXMuaW52b2x2ZXNUb2tlbih0b2tlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gdG9rZW4uZXF1YWxzKHRoaXMudG9rZW4wKSA/IHRoaXMudG9rZW4wUHJpY2UgOiB0aGlzLnRva2VuMVByaWNlO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGNoYWluIElEIG9mIHRoZSB0b2tlbnMgaW4gdGhlIHBhaXIuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVzZXJ2ZU9mID0gZnVuY3Rpb24gcmVzZXJ2ZU9mKHRva2VuKSB7XG4gICAgIXRoaXMuaW52b2x2ZXNUb2tlbih0b2tlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gdG9rZW4uZXF1YWxzKHRoaXMudG9rZW4wKSA/IHRoaXMucmVzZXJ2ZTAgOiB0aGlzLnJlc2VydmUxO1xuICB9O1xuXG4gIF9wcm90by5nZXRPdXRwdXRBbW91bnQgPSBmdW5jdGlvbiBnZXRPdXRwdXRBbW91bnQoaW5wdXRBbW91bnQpIHtcbiAgICAhdGhpcy5pbnZvbHZlc1Rva2VuKGlucHV0QW1vdW50LmN1cnJlbmN5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1RPS0VOJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKEpTQkkuZXF1YWwodGhpcy5yZXNlcnZlMC5xdW90aWVudCwgWkVSTykgfHwgSlNCSS5lcXVhbCh0aGlzLnJlc2VydmUxLnF1b3RpZW50LCBaRVJPKSkge1xuICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudFJlc2VydmVzRXJyb3IoKTtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXRSZXNlcnZlID0gdGhpcy5yZXNlcnZlT2YoaW5wdXRBbW91bnQuY3VycmVuY3kpO1xuICAgIHZhciBvdXRwdXRSZXNlcnZlID0gdGhpcy5yZXNlcnZlT2YoaW5wdXRBbW91bnQuY3VycmVuY3kuZXF1YWxzKHRoaXMudG9rZW4wKSA/IHRoaXMudG9rZW4xIDogdGhpcy50b2tlbjApO1xuICAgIHZhciBpbnB1dEFtb3VudFdpdGhGZWUgPSBKU0JJLm11bHRpcGx5KGlucHV0QW1vdW50LnF1b3RpZW50LCBfOTk3KTtcbiAgICB2YXIgbnVtZXJhdG9yID0gSlNCSS5tdWx0aXBseShpbnB1dEFtb3VudFdpdGhGZWUsIG91dHB1dFJlc2VydmUucXVvdGllbnQpO1xuICAgIHZhciBkZW5vbWluYXRvciA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkoaW5wdXRSZXNlcnZlLnF1b3RpZW50LCBfMTAwMCksIGlucHV0QW1vdW50V2l0aEZlZSk7XG4gICAgdmFyIG91dHB1dEFtb3VudCA9IEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQoaW5wdXRBbW91bnQuY3VycmVuY3kuZXF1YWxzKHRoaXMudG9rZW4wKSA/IHRoaXMudG9rZW4xIDogdGhpcy50b2tlbjAsIEpTQkkuZGl2aWRlKG51bWVyYXRvciwgZGVub21pbmF0b3IpKTtcblxuICAgIGlmIChKU0JJLmVxdWFsKG91dHB1dEFtb3VudC5xdW90aWVudCwgWkVSTykpIHtcbiAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvdXRwdXRBbW91bnQsIG5ldyBQYWlyKGlucHV0UmVzZXJ2ZS5hZGQoaW5wdXRBbW91bnQpLCBvdXRwdXRSZXNlcnZlLnN1YnRyYWN0KG91dHB1dEFtb3VudCkpXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0SW5wdXRBbW91bnQgPSBmdW5jdGlvbiBnZXRJbnB1dEFtb3VudChvdXRwdXRBbW91bnQpIHtcbiAgICAhdGhpcy5pbnZvbHZlc1Rva2VuKG91dHB1dEFtb3VudC5jdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmIChKU0JJLmVxdWFsKHRoaXMucmVzZXJ2ZTAucXVvdGllbnQsIFpFUk8pIHx8IEpTQkkuZXF1YWwodGhpcy5yZXNlcnZlMS5xdW90aWVudCwgWkVSTykgfHwgSlNCSS5ncmVhdGVyVGhhbk9yRXF1YWwob3V0cHV0QW1vdW50LnF1b3RpZW50LCB0aGlzLnJlc2VydmVPZihvdXRwdXRBbW91bnQuY3VycmVuY3kpLnF1b3RpZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudFJlc2VydmVzRXJyb3IoKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0UmVzZXJ2ZSA9IHRoaXMucmVzZXJ2ZU9mKG91dHB1dEFtb3VudC5jdXJyZW5jeSk7XG4gICAgdmFyIGlucHV0UmVzZXJ2ZSA9IHRoaXMucmVzZXJ2ZU9mKG91dHB1dEFtb3VudC5jdXJyZW5jeS5lcXVhbHModGhpcy50b2tlbjApID8gdGhpcy50b2tlbjEgOiB0aGlzLnRva2VuMCk7XG4gICAgdmFyIG51bWVyYXRvciA9IEpTQkkubXVsdGlwbHkoSlNCSS5tdWx0aXBseShpbnB1dFJlc2VydmUucXVvdGllbnQsIG91dHB1dEFtb3VudC5xdW90aWVudCksIF8xMDAwKTtcbiAgICB2YXIgZGVub21pbmF0b3IgPSBKU0JJLm11bHRpcGx5KEpTQkkuc3VidHJhY3Qob3V0cHV0UmVzZXJ2ZS5xdW90aWVudCwgb3V0cHV0QW1vdW50LnF1b3RpZW50KSwgXzk5Nyk7XG4gICAgdmFyIGlucHV0QW1vdW50ID0gQ3VycmVuY3lBbW91bnQuZnJvbVJhd0Ftb3VudChvdXRwdXRBbW91bnQuY3VycmVuY3kuZXF1YWxzKHRoaXMudG9rZW4wKSA/IHRoaXMudG9rZW4xIDogdGhpcy50b2tlbjAsIEpTQkkuYWRkKEpTQkkuZGl2aWRlKG51bWVyYXRvciwgZGVub21pbmF0b3IpLCBPTkUpKTtcbiAgICByZXR1cm4gW2lucHV0QW1vdW50LCBuZXcgUGFpcihpbnB1dFJlc2VydmUuYWRkKGlucHV0QW1vdW50KSwgb3V0cHV0UmVzZXJ2ZS5zdWJ0cmFjdChvdXRwdXRBbW91bnQpKV07XG4gIH07XG5cbiAgX3Byb3RvLmdldExpcXVpZGl0eU1pbnRlZCA9IGZ1bmN0aW9uIGdldExpcXVpZGl0eU1pbnRlZCh0b3RhbFN1cHBseSwgdG9rZW5BbW91bnRBLCB0b2tlbkFtb3VudEIpIHtcbiAgICAhdG90YWxTdXBwbHkuY3VycmVuY3kuZXF1YWxzKHRoaXMubGlxdWlkaXR5VG9rZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTElRVUlESVRZJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciB0b2tlbkFtb3VudHMgPSB0b2tlbkFtb3VudEEuY3VycmVuY3kuc29ydHNCZWZvcmUodG9rZW5BbW91bnRCLmN1cnJlbmN5KSAvLyBkb2VzIHNhZmV0eSBjaGVja3NcbiAgICA/IFt0b2tlbkFtb3VudEEsIHRva2VuQW1vdW50Ql0gOiBbdG9rZW5BbW91bnRCLCB0b2tlbkFtb3VudEFdO1xuICAgICEodG9rZW5BbW91bnRzWzBdLmN1cnJlbmN5LmVxdWFscyh0aGlzLnRva2VuMCkgJiYgdG9rZW5BbW91bnRzWzFdLmN1cnJlbmN5LmVxdWFscyh0aGlzLnRva2VuMSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVE9LRU4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGxpcXVpZGl0eTtcblxuICAgIGlmIChKU0JJLmVxdWFsKHRvdGFsU3VwcGx5LnF1b3RpZW50LCBaRVJPKSkge1xuICAgICAgbGlxdWlkaXR5ID0gSlNCSS5zdWJ0cmFjdChzcXJ0KEpTQkkubXVsdGlwbHkodG9rZW5BbW91bnRzWzBdLnF1b3RpZW50LCB0b2tlbkFtb3VudHNbMV0ucXVvdGllbnQpKSwgTUlOSU1VTV9MSVFVSURJVFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW1vdW50MCA9IEpTQkkuZGl2aWRlKEpTQkkubXVsdGlwbHkodG9rZW5BbW91bnRzWzBdLnF1b3RpZW50LCB0b3RhbFN1cHBseS5xdW90aWVudCksIHRoaXMucmVzZXJ2ZTAucXVvdGllbnQpO1xuICAgICAgdmFyIGFtb3VudDEgPSBKU0JJLmRpdmlkZShKU0JJLm11bHRpcGx5KHRva2VuQW1vdW50c1sxXS5xdW90aWVudCwgdG90YWxTdXBwbHkucXVvdGllbnQpLCB0aGlzLnJlc2VydmUxLnF1b3RpZW50KTtcbiAgICAgIGxpcXVpZGl0eSA9IEpTQkkubGVzc1RoYW5PckVxdWFsKGFtb3VudDAsIGFtb3VudDEpID8gYW1vdW50MCA6IGFtb3VudDE7XG4gICAgfVxuXG4gICAgaWYgKCFKU0JJLmdyZWF0ZXJUaGFuKGxpcXVpZGl0eSwgWkVSTykpIHtcbiAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQodGhpcy5saXF1aWRpdHlUb2tlbiwgbGlxdWlkaXR5KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TGlxdWlkaXR5VmFsdWUgPSBmdW5jdGlvbiBnZXRMaXF1aWRpdHlWYWx1ZSh0b2tlbiwgdG90YWxTdXBwbHksIGxpcXVpZGl0eSwgZmVlT24sIGtMYXN0KSB7XG4gICAgaWYgKGZlZU9uID09PSB2b2lkIDApIHtcbiAgICAgIGZlZU9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgIXRoaXMuaW52b2x2ZXNUb2tlbih0b2tlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhdG90YWxTdXBwbHkuY3VycmVuY3kuZXF1YWxzKHRoaXMubGlxdWlkaXR5VG9rZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVE9UQUxfU1VQUExZJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICFsaXF1aWRpdHkuY3VycmVuY3kuZXF1YWxzKHRoaXMubGlxdWlkaXR5VG9rZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTElRVUlESVRZJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICFKU0JJLmxlc3NUaGFuT3JFcXVhbChsaXF1aWRpdHkucXVvdGllbnQsIHRvdGFsU3VwcGx5LnF1b3RpZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0xJUVVJRElUWScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgdG90YWxTdXBwbHlBZGp1c3RlZDtcblxuICAgIGlmICghZmVlT24pIHtcbiAgICAgIHRvdGFsU3VwcGx5QWRqdXN0ZWQgPSB0b3RhbFN1cHBseTtcbiAgICB9IGVsc2Uge1xuICAgICAgISEha0xhc3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdLX0xBU1QnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIga0xhc3RQYXJzZWQgPSBKU0JJLkJpZ0ludChrTGFzdCk7XG5cbiAgICAgIGlmICghSlNCSS5lcXVhbChrTGFzdFBhcnNlZCwgWkVSTykpIHtcbiAgICAgICAgdmFyIHJvb3RLID0gc3FydChKU0JJLm11bHRpcGx5KHRoaXMucmVzZXJ2ZTAucXVvdGllbnQsIHRoaXMucmVzZXJ2ZTEucXVvdGllbnQpKTtcbiAgICAgICAgdmFyIHJvb3RLTGFzdCA9IHNxcnQoa0xhc3RQYXJzZWQpO1xuXG4gICAgICAgIGlmIChKU0JJLmdyZWF0ZXJUaGFuKHJvb3RLLCByb290S0xhc3QpKSB7XG4gICAgICAgICAgdmFyIG51bWVyYXRvciA9IEpTQkkubXVsdGlwbHkodG90YWxTdXBwbHkucXVvdGllbnQsIEpTQkkuc3VidHJhY3Qocm9vdEssIHJvb3RLTGFzdCkpO1xuICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IEpTQkkuYWRkKEpTQkkubXVsdGlwbHkocm9vdEssIEZJVkUpLCByb290S0xhc3QpO1xuICAgICAgICAgIHZhciBmZWVMaXF1aWRpdHkgPSBKU0JJLmRpdmlkZShudW1lcmF0b3IsIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICB0b3RhbFN1cHBseUFkanVzdGVkID0gdG90YWxTdXBwbHkuYWRkKEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQodGhpcy5saXF1aWRpdHlUb2tlbiwgZmVlTGlxdWlkaXR5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxTdXBwbHlBZGp1c3RlZCA9IHRvdGFsU3VwcGx5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3RhbFN1cHBseUFkanVzdGVkID0gdG90YWxTdXBwbHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQodG9rZW4sIEpTQkkuZGl2aWRlKEpTQkkubXVsdGlwbHkobGlxdWlkaXR5LnF1b3RpZW50LCB0aGlzLnJlc2VydmVPZih0b2tlbikucXVvdGllbnQpLCB0b3RhbFN1cHBseUFkanVzdGVkLnF1b3RpZW50KSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFBhaXIsIFt7XG4gICAga2V5OiBcInRva2VuMFByaWNlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy50b2tlbkFtb3VudHNbMV0uZGl2aWRlKHRoaXMudG9rZW5BbW91bnRzWzBdKTtcbiAgICAgIHJldHVybiBuZXcgUHJpY2UodGhpcy50b2tlbjAsIHRoaXMudG9rZW4xLCByZXN1bHQuZGVub21pbmF0b3IsIHJlc3VsdC5udW1lcmF0b3IpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWlkIHByaWNlIG9mIHRoZSBwYWlyIGluIHRlcm1zIG9mIHRva2VuMSwgaS5lLiB0aGUgcmF0aW8gb2YgcmVzZXJ2ZTAgdG8gcmVzZXJ2ZTFcclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9rZW4xUHJpY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnRva2VuQW1vdW50c1swXS5kaXZpZGUodGhpcy50b2tlbkFtb3VudHNbMV0pO1xuICAgICAgcmV0dXJuIG5ldyBQcmljZSh0aGlzLnRva2VuMSwgdGhpcy50b2tlbjAsIHJlc3VsdC5kZW5vbWluYXRvciwgcmVzdWx0Lm51bWVyYXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoYWluSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuMC5jaGFpbklkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2tlbjBcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRva2VuQW1vdW50c1swXS5jdXJyZW5jeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9rZW4xXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbkFtb3VudHNbMV0uY3VycmVuY3k7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2VydmUwXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbkFtb3VudHNbMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2VydmUxXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbkFtb3VudHNbMV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhaXI7XG59KCk7XG5cbnZhciBSb3V0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdXRlKHBhaXJzLCBpbnB1dCwgb3V0cHV0KSB7XG4gICAgdGhpcy5fbWlkUHJpY2UgPSBudWxsO1xuICAgICEocGFpcnMubGVuZ3RoID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdQQUlSUycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgY2hhaW5JZCA9IHBhaXJzWzBdLmNoYWluSWQ7XG4gICAgIXBhaXJzLmV2ZXJ5KGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICByZXR1cm4gcGFpci5jaGFpbklkID09PSBjaGFpbklkO1xuICAgIH0pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ0hBSU5fSURTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciB3cmFwcGVkSW5wdXQgPSBpbnB1dC53cmFwcGVkO1xuICAgICFwYWlyc1swXS5pbnZvbHZlc1Rva2VuKHdyYXBwZWRJbnB1dCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTlBVVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBvdXRwdXQgPT09ICd1bmRlZmluZWQnIHx8IHBhaXJzW3BhaXJzLmxlbmd0aCAtIDFdLmludm9sdmVzVG9rZW4ob3V0cHV0LndyYXBwZWQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ09VVFBVVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgcGF0aCA9IFt3cmFwcGVkSW5wdXRdO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShwYWlycy5lbnRyaWVzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgICAgaSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIHBhaXIgPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgIHZhciBjdXJyZW50SW5wdXQgPSBwYXRoW2ldO1xuICAgICAgIShjdXJyZW50SW5wdXQuZXF1YWxzKHBhaXIudG9rZW4wKSB8fCBjdXJyZW50SW5wdXQuZXF1YWxzKHBhaXIudG9rZW4xKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdQQVRIJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICB2YXIgX291dHB1dCA9IGN1cnJlbnRJbnB1dC5lcXVhbHMocGFpci50b2tlbjApID8gcGFpci50b2tlbjEgOiBwYWlyLnRva2VuMDtcblxuICAgICAgcGF0aC5wdXNoKF9vdXRwdXQpO1xuICAgIH1cblxuICAgIHRoaXMucGFpcnMgPSBwYWlycztcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSb3V0ZSwgW3tcbiAgICBrZXk6IFwibWlkUHJpY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLl9taWRQcmljZSAhPT0gbnVsbCkgcmV0dXJuIHRoaXMuX21pZFByaWNlO1xuICAgICAgdmFyIHByaWNlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0aGlzLnBhaXJzLmVudHJpZXMoKSksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc3RlcDIudmFsdWUsXG4gICAgICAgICAgICBpID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgcGFpciA9IF9zdGVwMiR2YWx1ZVsxXTtcbiAgICAgICAgcHJpY2VzLnB1c2godGhpcy5wYXRoW2ldLmVxdWFscyhwYWlyLnRva2VuMCkgPyBuZXcgUHJpY2UocGFpci5yZXNlcnZlMC5jdXJyZW5jeSwgcGFpci5yZXNlcnZlMS5jdXJyZW5jeSwgcGFpci5yZXNlcnZlMC5xdW90aWVudCwgcGFpci5yZXNlcnZlMS5xdW90aWVudCkgOiBuZXcgUHJpY2UocGFpci5yZXNlcnZlMS5jdXJyZW5jeSwgcGFpci5yZXNlcnZlMC5jdXJyZW5jeSwgcGFpci5yZXNlcnZlMS5xdW90aWVudCwgcGFpci5yZXNlcnZlMC5xdW90aWVudCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVkdWNlZCA9IHByaWNlcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yLm11bHRpcGx5KGN1cnJlbnRWYWx1ZSk7XG4gICAgICB9LCBwcmljZXNbMF0pO1xuICAgICAgcmV0dXJuIHRoaXMuX21pZFByaWNlID0gbmV3IFByaWNlKHRoaXMuaW5wdXQsIHRoaXMub3V0cHV0LCByZWR1Y2VkLmRlbm9taW5hdG9yLCByZWR1Y2VkLm51bWVyYXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoYWluSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhaXJzWzBdLmNoYWluSWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJvdXRlO1xufSgpO1xuXG4vLyBpbiBpbmNyZWFzaW5nIG9yZGVyLiBpLmUuIHRoZSBiZXN0IHRyYWRlcyBoYXZlIHRoZSBtb3N0IG91dHB1dHMgZm9yIHRoZSBsZWFzdCBpbnB1dHMgYW5kIGFyZSBzb3J0ZWQgZmlyc3RcblxuZnVuY3Rpb24gaW5wdXRPdXRwdXRDb21wYXJhdG9yKGEsIGIpIHtcbiAgLy8gbXVzdCBoYXZlIHNhbWUgaW5wdXQgYW5kIG91dHB1dCB0b2tlbiBmb3IgY29tcGFyaXNvblxuICAhYS5pbnB1dEFtb3VudC5jdXJyZW5jeS5lcXVhbHMoYi5pbnB1dEFtb3VudC5jdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTlBVVF9DVVJSRU5DWScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIWEub3V0cHV0QW1vdW50LmN1cnJlbmN5LmVxdWFscyhiLm91dHB1dEFtb3VudC5jdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdPVVRQVVRfQ1VSUkVOQ1knKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaWYgKGEub3V0cHV0QW1vdW50LmVxdWFsVG8oYi5vdXRwdXRBbW91bnQpKSB7XG4gICAgaWYgKGEuaW5wdXRBbW91bnQuZXF1YWxUbyhiLmlucHV0QW1vdW50KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSAvLyB0cmFkZSBBIHJlcXVpcmVzIGxlc3MgaW5wdXQgdGhhbiB0cmFkZSBCLCBzbyBBIHNob3VsZCBjb21lIGZpcnN0XG5cblxuICAgIGlmIChhLmlucHV0QW1vdW50Lmxlc3NUaGFuKGIuaW5wdXRBbW91bnQpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyB0cmFkZUEgaGFzIGxlc3Mgb3V0cHV0IHRoYW4gdHJhZGUgQiwgc28gc2hvdWxkIGNvbWUgc2Vjb25kXG4gICAgaWYgKGEub3V0cHV0QW1vdW50Lmxlc3NUaGFuKGIub3V0cHV0QW1vdW50KSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbn0gLy8gZXh0ZW5zaW9uIG9mIHRoZSBpbnB1dCBvdXRwdXQgY29tcGFyYXRvciB0aGF0IGFsc28gY29uc2lkZXJzIG90aGVyIGRpbWVuc2lvbnMgb2YgdGhlIHRyYWRlIGluIHJhbmtpbmcgdGhlbVxuXG5mdW5jdGlvbiB0cmFkZUNvbXBhcmF0b3IoYSwgYikge1xuICB2YXIgaW9Db21wID0gaW5wdXRPdXRwdXRDb21wYXJhdG9yKGEsIGIpO1xuXG4gIGlmIChpb0NvbXAgIT09IDApIHtcbiAgICByZXR1cm4gaW9Db21wO1xuICB9IC8vIGNvbnNpZGVyIGxvd2VzdCBzbGlwcGFnZSBuZXh0LCBzaW5jZSB0aGVzZSBhcmUgbGVzcyBsaWtlbHkgdG8gZmFpbFxuXG5cbiAgaWYgKGEucHJpY2VJbXBhY3QubGVzc1RoYW4oYi5wcmljZUltcGFjdCkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYS5wcmljZUltcGFjdC5ncmVhdGVyVGhhbihiLnByaWNlSW1wYWN0KSkge1xuICAgIHJldHVybiAxO1xuICB9IC8vIGZpbmFsbHkgY29uc2lkZXIgdGhlIG51bWJlciBvZiBob3BzIHNpbmNlIGVhY2ggaG9wIGNvc3RzIGdhc1xuXG5cbiAgcmV0dXJuIGEucm91dGUucGF0aC5sZW5ndGggLSBiLnJvdXRlLnBhdGgubGVuZ3RoO1xufVxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSB0cmFkZSBleGVjdXRlZCBhZ2FpbnN0IGEgbGlzdCBvZiBwYWlycy5cclxuICogRG9lcyBub3QgYWNjb3VudCBmb3Igc2xpcHBhZ2UsIGkuZS4gdHJhZGVzIHRoYXQgZnJvbnQgcnVuIHRoaXMgdHJhZGUgYW5kIG1vdmUgdGhlIHByaWNlLlxyXG4gKi9cblxudmFyIFRyYWRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhZGUocm91dGUsIGFtb3VudCwgdHJhZGVUeXBlKSB7XG4gICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgIHRoaXMudHJhZGVUeXBlID0gdHJhZGVUeXBlO1xuICAgIHZhciB0b2tlbkFtb3VudHMgPSBuZXcgQXJyYXkocm91dGUucGF0aC5sZW5ndGgpO1xuXG4gICAgaWYgKHRyYWRlVHlwZSA9PT0gVHJhZGVUeXBlLkVYQUNUX0lOUFVUKSB7XG4gICAgICAhYW1vdW50LmN1cnJlbmN5LmVxdWFscyhyb3V0ZS5pbnB1dCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTlBVVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHRva2VuQW1vdW50c1swXSA9IGFtb3VudC53cmFwcGVkO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLnBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBwYWlyID0gcm91dGUucGFpcnNbaV07XG5cbiAgICAgICAgdmFyIF9wYWlyJGdldE91dHB1dEFtb3VudCA9IHBhaXIuZ2V0T3V0cHV0QW1vdW50KHRva2VuQW1vdW50c1tpXSksXG4gICAgICAgICAgICBvdXRwdXRBbW91bnQgPSBfcGFpciRnZXRPdXRwdXRBbW91bnRbMF07XG5cbiAgICAgICAgdG9rZW5BbW91bnRzW2kgKyAxXSA9IG91dHB1dEFtb3VudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnB1dEFtb3VudCA9IEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHJvdXRlLmlucHV0LCBhbW91bnQubnVtZXJhdG9yLCBhbW91bnQuZGVub21pbmF0b3IpO1xuICAgICAgdGhpcy5vdXRwdXRBbW91bnQgPSBDdXJyZW5jeUFtb3VudC5mcm9tRnJhY3Rpb25hbEFtb3VudChyb3V0ZS5vdXRwdXQsIHRva2VuQW1vdW50c1t0b2tlbkFtb3VudHMubGVuZ3RoIC0gMV0ubnVtZXJhdG9yLCB0b2tlbkFtb3VudHNbdG9rZW5BbW91bnRzLmxlbmd0aCAtIDFdLmRlbm9taW5hdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIWFtb3VudC5jdXJyZW5jeS5lcXVhbHMocm91dGUub3V0cHV0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ09VVFBVVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHRva2VuQW1vdW50c1t0b2tlbkFtb3VudHMubGVuZ3RoIC0gMV0gPSBhbW91bnQud3JhcHBlZDtcblxuICAgICAgZm9yICh2YXIgX2kgPSByb3V0ZS5wYXRoLmxlbmd0aCAtIDE7IF9pID4gMDsgX2ktLSkge1xuICAgICAgICB2YXIgX3BhaXIgPSByb3V0ZS5wYWlyc1tfaSAtIDFdO1xuXG4gICAgICAgIHZhciBfcGFpciRnZXRJbnB1dEFtb3VudCA9IF9wYWlyLmdldElucHV0QW1vdW50KHRva2VuQW1vdW50c1tfaV0pLFxuICAgICAgICAgICAgaW5wdXRBbW91bnQgPSBfcGFpciRnZXRJbnB1dEFtb3VudFswXTtcblxuICAgICAgICB0b2tlbkFtb3VudHNbX2kgLSAxXSA9IGlucHV0QW1vdW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlucHV0QW1vdW50ID0gQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQocm91dGUuaW5wdXQsIHRva2VuQW1vdW50c1swXS5udW1lcmF0b3IsIHRva2VuQW1vdW50c1swXS5kZW5vbWluYXRvcik7XG4gICAgICB0aGlzLm91dHB1dEFtb3VudCA9IEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHJvdXRlLm91dHB1dCwgYW1vdW50Lm51bWVyYXRvciwgYW1vdW50LmRlbm9taW5hdG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4ZWN1dGlvblByaWNlID0gbmV3IFByaWNlKHRoaXMuaW5wdXRBbW91bnQuY3VycmVuY3ksIHRoaXMub3V0cHV0QW1vdW50LmN1cnJlbmN5LCB0aGlzLmlucHV0QW1vdW50LnF1b3RpZW50LCB0aGlzLm91dHB1dEFtb3VudC5xdW90aWVudCk7XG4gICAgdGhpcy5wcmljZUltcGFjdCA9IGNvbXB1dGVQcmljZUltcGFjdChyb3V0ZS5taWRQcmljZSwgdGhpcy5pbnB1dEFtb3VudCwgdGhpcy5vdXRwdXRBbW91bnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdHMgYW4gZXhhY3QgaW4gdHJhZGUgd2l0aCB0aGUgZ2l2ZW4gYW1vdW50IGluIGFuZCByb3V0ZVxyXG4gICAqIEBwYXJhbSByb3V0ZSByb3V0ZSBvZiB0aGUgZXhhY3QgaW4gdHJhZGVcclxuICAgKiBAcGFyYW0gYW1vdW50SW4gdGhlIGFtb3VudCBiZWluZyBwYXNzZWQgaW5cclxuICAgKi9cblxuXG4gIFRyYWRlLmV4YWN0SW4gPSBmdW5jdGlvbiBleGFjdEluKHJvdXRlLCBhbW91bnRJbikge1xuICAgIHJldHVybiBuZXcgVHJhZGUocm91dGUsIGFtb3VudEluLCBUcmFkZVR5cGUuRVhBQ1RfSU5QVVQpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdHMgYW4gZXhhY3Qgb3V0IHRyYWRlIHdpdGggdGhlIGdpdmVuIGFtb3VudCBvdXQgYW5kIHJvdXRlXHJcbiAgICogQHBhcmFtIHJvdXRlIHJvdXRlIG9mIHRoZSBleGFjdCBvdXQgdHJhZGVcclxuICAgKiBAcGFyYW0gYW1vdW50T3V0IHRoZSBhbW91bnQgcmV0dXJuZWQgYnkgdGhlIHRyYWRlXHJcbiAgICovXG4gIDtcblxuICBUcmFkZS5leGFjdE91dCA9IGZ1bmN0aW9uIGV4YWN0T3V0KHJvdXRlLCBhbW91bnRPdXQpIHtcbiAgICByZXR1cm4gbmV3IFRyYWRlKHJvdXRlLCBhbW91bnRPdXQsIFRyYWRlVHlwZS5FWEFDVF9PVVRQVVQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWluaW11bSBhbW91bnQgdGhhdCBtdXN0IGJlIHJlY2VpdmVkIGZyb20gdGhpcyB0cmFkZSBmb3IgdGhlIGdpdmVuIHNsaXBwYWdlIHRvbGVyYW5jZVxyXG4gICAqIEBwYXJhbSBzbGlwcGFnZVRvbGVyYW5jZSB0b2xlcmFuY2Ugb2YgdW5mYXZvcmFibGUgc2xpcHBhZ2UgZnJvbSB0aGUgZXhlY3V0aW9uIHByaWNlIG9mIHRoaXMgdHJhZGVcclxuICAgKi9cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBUcmFkZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm1pbmltdW1BbW91bnRPdXQgPSBmdW5jdGlvbiBtaW5pbXVtQW1vdW50T3V0KHNsaXBwYWdlVG9sZXJhbmNlKSB7XG4gICAgISFzbGlwcGFnZVRvbGVyYW5jZS5sZXNzVGhhbihaRVJPKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1NMSVBQQUdFX1RPTEVSQU5DRScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmICh0aGlzLnRyYWRlVHlwZSA9PT0gVHJhZGVUeXBlLkVYQUNUX09VVFBVVCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0QW1vdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2xpcHBhZ2VBZGp1c3RlZEFtb3VudE91dCA9IG5ldyBGcmFjdGlvbihPTkUpLmFkZChzbGlwcGFnZVRvbGVyYW5jZSkuaW52ZXJ0KCkubXVsdGlwbHkodGhpcy5vdXRwdXRBbW91bnQucXVvdGllbnQpLnF1b3RpZW50O1xuICAgICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQodGhpcy5vdXRwdXRBbW91bnQuY3VycmVuY3ksIHNsaXBwYWdlQWRqdXN0ZWRBbW91bnRPdXQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIG1heGltdW0gYW1vdW50IGluIHRoYXQgY2FuIGJlIHNwZW50IHZpYSB0aGlzIHRyYWRlIGZvciB0aGUgZ2l2ZW4gc2xpcHBhZ2UgdG9sZXJhbmNlXHJcbiAgICogQHBhcmFtIHNsaXBwYWdlVG9sZXJhbmNlIHRvbGVyYW5jZSBvZiB1bmZhdm9yYWJsZSBzbGlwcGFnZSBmcm9tIHRoZSBleGVjdXRpb24gcHJpY2Ugb2YgdGhpcyB0cmFkZVxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm1heGltdW1BbW91bnRJbiA9IGZ1bmN0aW9uIG1heGltdW1BbW91bnRJbihzbGlwcGFnZVRvbGVyYW5jZSkge1xuICAgICEhc2xpcHBhZ2VUb2xlcmFuY2UubGVzc1RoYW4oWkVSTykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTTElQUEFHRV9UT0xFUkFOQ0UnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAodGhpcy50cmFkZVR5cGUgPT09IFRyYWRlVHlwZS5FWEFDVF9JTlBVVCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRBbW91bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzbGlwcGFnZUFkanVzdGVkQW1vdW50SW4gPSBuZXcgRnJhY3Rpb24oT05FKS5hZGQoc2xpcHBhZ2VUb2xlcmFuY2UpLm11bHRpcGx5KHRoaXMuaW5wdXRBbW91bnQucXVvdGllbnQpLnF1b3RpZW50O1xuICAgICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21SYXdBbW91bnQodGhpcy5pbnB1dEFtb3VudC5jdXJyZW5jeSwgc2xpcHBhZ2VBZGp1c3RlZEFtb3VudEluKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBsaXN0IG9mIHBhaXJzLCBhbmQgYSBmaXhlZCBhbW91bnQgaW4sIHJldHVybnMgdGhlIHRvcCBgbWF4TnVtUmVzdWx0c2AgdHJhZGVzIHRoYXQgZ28gZnJvbSBhbiBpbnB1dCB0b2tlblxyXG4gICAqIGFtb3VudCB0byBhbiBvdXRwdXQgdG9rZW4sIG1ha2luZyBhdCBtb3N0IGBtYXhIb3BzYCBob3BzLlxyXG4gICAqIE5vdGUgdGhpcyBkb2VzIG5vdCBjb25zaWRlciBhZ2dyZWdhdGlvbiwgYXMgcm91dGVzIGFyZSBsaW5lYXIuIEl0J3MgcG9zc2libGUgYSBiZXR0ZXIgcm91dGUgZXhpc3RzIGJ5IHNwbGl0dGluZ1xyXG4gICAqIHRoZSBhbW91bnQgaW4gYW1vbmcgbXVsdGlwbGUgcm91dGVzLlxyXG4gICAqIEBwYXJhbSBwYWlycyB0aGUgcGFpcnMgdG8gY29uc2lkZXIgaW4gZmluZGluZyB0aGUgYmVzdCB0cmFkZVxyXG4gICAqIEBwYXJhbSBuZXh0QW1vdW50SW4gZXhhY3QgYW1vdW50IG9mIGlucHV0IGN1cnJlbmN5IHRvIHNwZW5kXHJcbiAgICogQHBhcmFtIGN1cnJlbmN5T3V0IHRoZSBkZXNpcmVkIGN1cnJlbmN5IG91dFxyXG4gICAqIEBwYXJhbSBtYXhOdW1SZXN1bHRzIG1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuXHJcbiAgICogQHBhcmFtIG1heEhvcHMgbWF4aW11bSBudW1iZXIgb2YgaG9wcyBhIHJldHVybmVkIHRyYWRlIGNhbiBtYWtlLCBlLmcuIDEgaG9wIGdvZXMgdGhyb3VnaCBhIHNpbmdsZSBwYWlyXHJcbiAgICogQHBhcmFtIGN1cnJlbnRQYWlycyB1c2VkIGluIHJlY3Vyc2lvbjsgdGhlIGN1cnJlbnQgbGlzdCBvZiBwYWlyc1xyXG4gICAqIEBwYXJhbSBjdXJyZW5jeUFtb3VudEluIHVzZWQgaW4gcmVjdXJzaW9uOyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGN1cnJlbmN5QW1vdW50SW4gcGFyYW1ldGVyXHJcbiAgICogQHBhcmFtIGJlc3RUcmFkZXMgdXNlZCBpbiByZWN1cnNpb247IHRoZSBjdXJyZW50IGxpc3Qgb2YgYmVzdCB0cmFkZXNcclxuICAgKi9cbiAgO1xuXG4gIFRyYWRlLmJlc3RUcmFkZUV4YWN0SW4gPSBmdW5jdGlvbiBiZXN0VHJhZGVFeGFjdEluKHBhaXJzLCBjdXJyZW5jeUFtb3VudEluLCBjdXJyZW5jeU91dCwgX3RlbXAsIC8vIHVzZWQgaW4gcmVjdXJzaW9uLlxuICBjdXJyZW50UGFpcnMsIG5leHRBbW91bnRJbiwgYmVzdFRyYWRlcykge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYkbWF4TnVtUmVzdWx0cyA9IF9yZWYubWF4TnVtUmVzdWx0cyxcbiAgICAgICAgbWF4TnVtUmVzdWx0cyA9IF9yZWYkbWF4TnVtUmVzdWx0cyA9PT0gdm9pZCAwID8gMyA6IF9yZWYkbWF4TnVtUmVzdWx0cyxcbiAgICAgICAgX3JlZiRtYXhIb3BzID0gX3JlZi5tYXhIb3BzLFxuICAgICAgICBtYXhIb3BzID0gX3JlZiRtYXhIb3BzID09PSB2b2lkIDAgPyAzIDogX3JlZiRtYXhIb3BzO1xuXG4gICAgaWYgKGN1cnJlbnRQYWlycyA9PT0gdm9pZCAwKSB7XG4gICAgICBjdXJyZW50UGFpcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAobmV4dEFtb3VudEluID09PSB2b2lkIDApIHtcbiAgICAgIG5leHRBbW91bnRJbiA9IGN1cnJlbmN5QW1vdW50SW47XG4gICAgfVxuXG4gICAgaWYgKGJlc3RUcmFkZXMgPT09IHZvaWQgMCkge1xuICAgICAgYmVzdFRyYWRlcyA9IFtdO1xuICAgIH1cblxuICAgICEocGFpcnMubGVuZ3RoID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdQQUlSUycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKG1heEhvcHMgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ01BWF9IT1BTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEoY3VycmVuY3lBbW91bnRJbiA9PT0gbmV4dEFtb3VudEluIHx8IGN1cnJlbnRQYWlycy5sZW5ndGggPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0lOVkFMSURfUkVDVVJTSU9OJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBhbW91bnRJbiA9IG5leHRBbW91bnRJbi53cmFwcGVkO1xuICAgIHZhciB0b2tlbk91dCA9IGN1cnJlbmN5T3V0LndyYXBwZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFpciA9IHBhaXJzW2ldOyAvLyBwYWlyIGlycmVsZXZhbnRcblxuICAgICAgaWYgKCFwYWlyLnRva2VuMC5lcXVhbHMoYW1vdW50SW4uY3VycmVuY3kpICYmICFwYWlyLnRva2VuMS5lcXVhbHMoYW1vdW50SW4uY3VycmVuY3kpKSBjb250aW51ZTtcbiAgICAgIGlmIChwYWlyLnJlc2VydmUwLmVxdWFsVG8oWkVSTykgfHwgcGFpci5yZXNlcnZlMS5lcXVhbFRvKFpFUk8pKSBjb250aW51ZTtcbiAgICAgIHZhciBhbW91bnRPdXQgPSB2b2lkIDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIDtcblxuICAgICAgICB2YXIgX3BhaXIkZ2V0T3V0cHV0QW1vdW50MiA9IHBhaXIuZ2V0T3V0cHV0QW1vdW50KGFtb3VudEluKTtcblxuICAgICAgICBhbW91bnRPdXQgPSBfcGFpciRnZXRPdXRwdXRBbW91bnQyWzBdO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gaW5wdXQgdG9vIGxvd1xuICAgICAgICBpZiAoZXJyb3IuaXNJbnN1ZmZpY2llbnRJbnB1dEFtb3VudEVycm9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gLy8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBvdXRwdXQgdG9rZW4sIHNvIHRoaXMgaXMgdGhlIGZpbmFsIHRyYWRlIG9mIG9uZSBvZiB0aGUgcGF0aHNcblxuXG4gICAgICBpZiAoYW1vdW50T3V0LmN1cnJlbmN5LmVxdWFscyh0b2tlbk91dCkpIHtcbiAgICAgICAgc29ydGVkSW5zZXJ0KGJlc3RUcmFkZXMsIG5ldyBUcmFkZShuZXcgUm91dGUoW10uY29uY2F0KGN1cnJlbnRQYWlycywgW3BhaXJdKSwgY3VycmVuY3lBbW91bnRJbi5jdXJyZW5jeSwgY3VycmVuY3lPdXQpLCBjdXJyZW5jeUFtb3VudEluLCBUcmFkZVR5cGUuRVhBQ1RfSU5QVVQpLCBtYXhOdW1SZXN1bHRzLCB0cmFkZUNvbXBhcmF0b3IpO1xuICAgICAgfSBlbHNlIGlmIChtYXhIb3BzID4gMSAmJiBwYWlycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBwYWlyc0V4Y2x1ZGluZ1RoaXNQYWlyID0gcGFpcnMuc2xpY2UoMCwgaSkuY29uY2F0KHBhaXJzLnNsaWNlKGkgKyAxLCBwYWlycy5sZW5ndGgpKTsgLy8gb3RoZXJ3aXNlLCBjb25zaWRlciBhbGwgdGhlIG90aGVyIHBhdGhzIHRoYXQgbGVhZCBmcm9tIHRoaXMgdG9rZW4gYXMgbG9uZyBhcyB3ZSBoYXZlIG5vdCBleGNlZWRlZCBtYXhIb3BzXG5cbiAgICAgICAgVHJhZGUuYmVzdFRyYWRlRXhhY3RJbihwYWlyc0V4Y2x1ZGluZ1RoaXNQYWlyLCBjdXJyZW5jeUFtb3VudEluLCBjdXJyZW5jeU91dCwge1xuICAgICAgICAgIG1heE51bVJlc3VsdHM6IG1heE51bVJlc3VsdHMsXG4gICAgICAgICAgbWF4SG9wczogbWF4SG9wcyAtIDFcbiAgICAgICAgfSwgW10uY29uY2F0KGN1cnJlbnRQYWlycywgW3BhaXJdKSwgYW1vdW50T3V0LCBiZXN0VHJhZGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdFRyYWRlcztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGV4ZWN1dGlvbiBwcmljZSBhZnRlciBhY2NvdW50aW5nIGZvciBzbGlwcGFnZSB0b2xlcmFuY2VcclxuICAgKiBAcGFyYW0gc2xpcHBhZ2VUb2xlcmFuY2UgdGhlIGFsbG93ZWQgdG9sZXJhdGVkIHNsaXBwYWdlXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ud29yc3RFeGVjdXRpb25QcmljZSA9IGZ1bmN0aW9uIHdvcnN0RXhlY3V0aW9uUHJpY2Uoc2xpcHBhZ2VUb2xlcmFuY2UpIHtcbiAgICByZXR1cm4gbmV3IFByaWNlKHRoaXMuaW5wdXRBbW91bnQuY3VycmVuY3ksIHRoaXMub3V0cHV0QW1vdW50LmN1cnJlbmN5LCB0aGlzLm1heGltdW1BbW91bnRJbihzbGlwcGFnZVRvbGVyYW5jZSkucXVvdGllbnQsIHRoaXMubWluaW11bUFtb3VudE91dChzbGlwcGFnZVRvbGVyYW5jZSkucXVvdGllbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIHNpbWlsYXIgdG8gdGhlIGFib3ZlIG1ldGhvZCBidXQgaW5zdGVhZCB0YXJnZXRzIGEgZml4ZWQgb3V0cHV0IGFtb3VudFxyXG4gICAqIGdpdmVuIGEgbGlzdCBvZiBwYWlycywgYW5kIGEgZml4ZWQgYW1vdW50IG91dCwgcmV0dXJucyB0aGUgdG9wIGBtYXhOdW1SZXN1bHRzYCB0cmFkZXMgdGhhdCBnbyBmcm9tIGFuIGlucHV0IHRva2VuXHJcbiAgICogdG8gYW4gb3V0cHV0IHRva2VuIGFtb3VudCwgbWFraW5nIGF0IG1vc3QgYG1heEhvcHNgIGhvcHNcclxuICAgKiBub3RlIHRoaXMgZG9lcyBub3QgY29uc2lkZXIgYWdncmVnYXRpb24sIGFzIHJvdXRlcyBhcmUgbGluZWFyLiBpdCdzIHBvc3NpYmxlIGEgYmV0dGVyIHJvdXRlIGV4aXN0cyBieSBzcGxpdHRpbmdcclxuICAgKiB0aGUgYW1vdW50IGluIGFtb25nIG11bHRpcGxlIHJvdXRlcy5cclxuICAgKiBAcGFyYW0gcGFpcnMgdGhlIHBhaXJzIHRvIGNvbnNpZGVyIGluIGZpbmRpbmcgdGhlIGJlc3QgdHJhZGVcclxuICAgKiBAcGFyYW0gY3VycmVuY3lJbiB0aGUgY3VycmVuY3kgdG8gc3BlbmRcclxuICAgKiBAcGFyYW0gbmV4dEFtb3VudE91dCB0aGUgZXhhY3QgYW1vdW50IG9mIGN1cnJlbmN5IG91dFxyXG4gICAqIEBwYXJhbSBtYXhOdW1SZXN1bHRzIG1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuXHJcbiAgICogQHBhcmFtIG1heEhvcHMgbWF4aW11bSBudW1iZXIgb2YgaG9wcyBhIHJldHVybmVkIHRyYWRlIGNhbiBtYWtlLCBlLmcuIDEgaG9wIGdvZXMgdGhyb3VnaCBhIHNpbmdsZSBwYWlyXHJcbiAgICogQHBhcmFtIGN1cnJlbnRQYWlycyB1c2VkIGluIHJlY3Vyc2lvbjsgdGhlIGN1cnJlbnQgbGlzdCBvZiBwYWlyc1xyXG4gICAqIEBwYXJhbSBjdXJyZW5jeUFtb3VudE91dCB1c2VkIGluIHJlY3Vyc2lvbjsgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBjdXJyZW5jeUFtb3VudE91dCBwYXJhbWV0ZXJcclxuICAgKiBAcGFyYW0gYmVzdFRyYWRlcyB1c2VkIGluIHJlY3Vyc2lvbjsgdGhlIGN1cnJlbnQgbGlzdCBvZiBiZXN0IHRyYWRlc1xyXG4gICAqL1xuICA7XG5cbiAgVHJhZGUuYmVzdFRyYWRlRXhhY3RPdXQgPSBmdW5jdGlvbiBiZXN0VHJhZGVFeGFjdE91dChwYWlycywgY3VycmVuY3lJbiwgY3VycmVuY3lBbW91bnRPdXQsIF90ZW1wMiwgLy8gdXNlZCBpbiByZWN1cnNpb24uXG4gIGN1cnJlbnRQYWlycywgbmV4dEFtb3VudE91dCwgYmVzdFRyYWRlcykge1xuICAgIHZhciBfcmVmMiA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICAgIF9yZWYyJG1heE51bVJlc3VsdHMgPSBfcmVmMi5tYXhOdW1SZXN1bHRzLFxuICAgICAgICBtYXhOdW1SZXN1bHRzID0gX3JlZjIkbWF4TnVtUmVzdWx0cyA9PT0gdm9pZCAwID8gMyA6IF9yZWYyJG1heE51bVJlc3VsdHMsXG4gICAgICAgIF9yZWYyJG1heEhvcHMgPSBfcmVmMi5tYXhIb3BzLFxuICAgICAgICBtYXhIb3BzID0gX3JlZjIkbWF4SG9wcyA9PT0gdm9pZCAwID8gMyA6IF9yZWYyJG1heEhvcHM7XG5cbiAgICBpZiAoY3VycmVudFBhaXJzID09PSB2b2lkIDApIHtcbiAgICAgIGN1cnJlbnRQYWlycyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChuZXh0QW1vdW50T3V0ID09PSB2b2lkIDApIHtcbiAgICAgIG5leHRBbW91bnRPdXQgPSBjdXJyZW5jeUFtb3VudE91dDtcbiAgICB9XG5cbiAgICBpZiAoYmVzdFRyYWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBiZXN0VHJhZGVzID0gW107XG4gICAgfVxuXG4gICAgIShwYWlycy5sZW5ndGggPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1BBSVJTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEobWF4SG9wcyA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTUFYX0hPUFMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIShjdXJyZW5jeUFtb3VudE91dCA9PT0gbmV4dEFtb3VudE91dCB8fCBjdXJyZW50UGFpcnMubGVuZ3RoID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTlZBTElEX1JFQ1VSU0lPTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgYW1vdW50T3V0ID0gbmV4dEFtb3VudE91dC53cmFwcGVkO1xuICAgIHZhciB0b2tlbkluID0gY3VycmVuY3lJbi53cmFwcGVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXTsgLy8gcGFpciBpcnJlbGV2YW50XG5cbiAgICAgIGlmICghcGFpci50b2tlbjAuZXF1YWxzKGFtb3VudE91dC5jdXJyZW5jeSkgJiYgIXBhaXIudG9rZW4xLmVxdWFscyhhbW91bnRPdXQuY3VycmVuY3kpKSBjb250aW51ZTtcbiAgICAgIGlmIChwYWlyLnJlc2VydmUwLmVxdWFsVG8oWkVSTykgfHwgcGFpci5yZXNlcnZlMS5lcXVhbFRvKFpFUk8pKSBjb250aW51ZTtcbiAgICAgIHZhciBhbW91bnRJbiA9IHZvaWQgMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgO1xuXG4gICAgICAgIHZhciBfcGFpciRnZXRJbnB1dEFtb3VudDIgPSBwYWlyLmdldElucHV0QW1vdW50KGFtb3VudE91dCk7XG5cbiAgICAgICAgYW1vdW50SW4gPSBfcGFpciRnZXRJbnB1dEFtb3VudDJbMF07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBub3QgZW5vdWdoIGxpcXVpZGl0eSBpbiB0aGlzIHBhaXJcbiAgICAgICAgaWYgKGVycm9yLmlzSW5zdWZmaWNpZW50UmVzZXJ2ZXNFcnJvcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgaW5wdXQgdG9rZW4sIHNvIHRoaXMgaXMgdGhlIGZpcnN0IHRyYWRlIG9mIG9uZSBvZiB0aGUgcGF0aHNcblxuXG4gICAgICBpZiAoYW1vdW50SW4uY3VycmVuY3kuZXF1YWxzKHRva2VuSW4pKSB7XG4gICAgICAgIHNvcnRlZEluc2VydChiZXN0VHJhZGVzLCBuZXcgVHJhZGUobmV3IFJvdXRlKFtwYWlyXS5jb25jYXQoY3VycmVudFBhaXJzKSwgY3VycmVuY3lJbiwgY3VycmVuY3lBbW91bnRPdXQuY3VycmVuY3kpLCBjdXJyZW5jeUFtb3VudE91dCwgVHJhZGVUeXBlLkVYQUNUX09VVFBVVCksIG1heE51bVJlc3VsdHMsIHRyYWRlQ29tcGFyYXRvcik7XG4gICAgICB9IGVsc2UgaWYgKG1heEhvcHMgPiAxICYmIHBhaXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIHBhaXJzRXhjbHVkaW5nVGhpc1BhaXIgPSBwYWlycy5zbGljZSgwLCBpKS5jb25jYXQocGFpcnMuc2xpY2UoaSArIDEsIHBhaXJzLmxlbmd0aCkpOyAvLyBvdGhlcndpc2UsIGNvbnNpZGVyIGFsbCB0aGUgb3RoZXIgcGF0aHMgdGhhdCBhcnJpdmUgYXQgdGhpcyB0b2tlbiBhcyBsb25nIGFzIHdlIGhhdmUgbm90IGV4Y2VlZGVkIG1heEhvcHNcblxuICAgICAgICBUcmFkZS5iZXN0VHJhZGVFeGFjdE91dChwYWlyc0V4Y2x1ZGluZ1RoaXNQYWlyLCBjdXJyZW5jeUluLCBjdXJyZW5jeUFtb3VudE91dCwge1xuICAgICAgICAgIG1heE51bVJlc3VsdHM6IG1heE51bVJlc3VsdHMsXG4gICAgICAgICAgbWF4SG9wczogbWF4SG9wcyAtIDFcbiAgICAgICAgfSwgW3BhaXJdLmNvbmNhdChjdXJyZW50UGFpcnMpLCBhbW91bnRJbiwgYmVzdFRyYWRlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3RUcmFkZXM7XG4gIH07XG5cbiAgcmV0dXJuIFRyYWRlO1xufSgpO1xuXG5mdW5jdGlvbiB0b0hleChjdXJyZW5jeUFtb3VudCkge1xuICByZXR1cm4gXCIweFwiICsgY3VycmVuY3lBbW91bnQucXVvdGllbnQudG9TdHJpbmcoMTYpO1xufVxuXG52YXIgWkVST19IRVggPSAnMHgwJztcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBVbmlzd2FwIFYyIFJvdXRlciwgYW5kIGhhcyBzdGF0aWMgbWV0aG9kcyBmb3IgaGVscGluZyBleGVjdXRlIHRyYWRlcy5cclxuICovXG5cbnZhciBSb3V0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBDYW5ub3QgYmUgY29uc3RydWN0ZWQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJvdXRlcigpIHt9XG4gIC8qKlxyXG4gICAqIFByb2R1Y2VzIHRoZSBvbi1jaGFpbiBtZXRob2QgbmFtZSB0byBjYWxsIGFuZCB0aGUgaGV4IGVuY29kZWQgcGFyYW1ldGVycyB0byBwYXNzIGFzIGFyZ3VtZW50cyBmb3IgYSBnaXZlbiB0cmFkZS5cclxuICAgKiBAcGFyYW0gdHJhZGUgdG8gcHJvZHVjZSBjYWxsIHBhcmFtZXRlcnMgZm9yXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyBmb3IgdGhlIGNhbGwgcGFyYW1ldGVyc1xyXG4gICAqL1xuXG5cbiAgUm91dGVyLnN3YXBDYWxsUGFyYW1ldGVycyA9IGZ1bmN0aW9uIHN3YXBDYWxsUGFyYW1ldGVycyh0cmFkZSwgb3B0aW9ucykge1xuICAgIHZhciBldGhlckluID0gdHJhZGUuaW5wdXRBbW91bnQuY3VycmVuY3kuaXNOYXRpdmU7XG4gICAgdmFyIGV0aGVyT3V0ID0gdHJhZGUub3V0cHV0QW1vdW50LmN1cnJlbmN5LmlzTmF0aXZlOyAvLyB0aGUgcm91dGVyIGRvZXMgbm90IHN1cHBvcnQgYm90aCBldGhlciBpbiBhbmQgb3V0XG5cbiAgICAhIShldGhlckluICYmIGV0aGVyT3V0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0VUSEVSX0lOX09VVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKCEoJ3R0bCcgaW4gb3B0aW9ucykgfHwgb3B0aW9ucy50dGwgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1RUTCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgdG8gPSB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhvcHRpb25zLnJlY2lwaWVudCk7XG4gICAgdmFyIGFtb3VudEluID0gdG9IZXgodHJhZGUubWF4aW11bUFtb3VudEluKG9wdGlvbnMuYWxsb3dlZFNsaXBwYWdlKSk7XG4gICAgdmFyIGFtb3VudE91dCA9IHRvSGV4KHRyYWRlLm1pbmltdW1BbW91bnRPdXQob3B0aW9ucy5hbGxvd2VkU2xpcHBhZ2UpKTtcbiAgICB2YXIgcGF0aCA9IHRyYWRlLnJvdXRlLnBhdGgubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLmFkZHJlc3M7XG4gICAgfSk7XG4gICAgdmFyIGRlYWRsaW5lID0gJ3R0bCcgaW4gb3B0aW9ucyA/IFwiMHhcIiArIChNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyBvcHRpb25zLnR0bCkudG9TdHJpbmcoMTYpIDogXCIweFwiICsgb3B0aW9ucy5kZWFkbGluZS50b1N0cmluZygxNik7XG4gICAgdmFyIHVzZUZlZU9uVHJhbnNmZXIgPSBCb29sZWFuKG9wdGlvbnMuZmVlT25UcmFuc2Zlcik7XG4gICAgdmFyIG1ldGhvZE5hbWU7XG4gICAgdmFyIGFyZ3M7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgc3dpdGNoICh0cmFkZS50cmFkZVR5cGUpIHtcbiAgICAgIGNhc2UgVHJhZGVUeXBlLkVYQUNUX0lOUFVUOlxuICAgICAgICBpZiAoZXRoZXJJbikge1xuICAgICAgICAgIG1ldGhvZE5hbWUgPSB1c2VGZWVPblRyYW5zZmVyID8gJ3N3YXBFeGFjdEVUSEZvclRva2Vuc1N1cHBvcnRpbmdGZWVPblRyYW5zZmVyVG9rZW5zJyA6ICdzd2FwRXhhY3RFVEhGb3JUb2tlbnMnOyAvLyAodWludCBhbW91bnRPdXRNaW4sIGFkZHJlc3NbXSBjYWxsZGF0YSBwYXRoLCBhZGRyZXNzIHRvLCB1aW50IGRlYWRsaW5lKVxuXG4gICAgICAgICAgYXJncyA9IFthbW91bnRPdXQsIHBhdGgsIHRvLCBkZWFkbGluZV07XG4gICAgICAgICAgdmFsdWUgPSBhbW91bnRJbjtcbiAgICAgICAgfSBlbHNlIGlmIChldGhlck91dCkge1xuICAgICAgICAgIG1ldGhvZE5hbWUgPSB1c2VGZWVPblRyYW5zZmVyID8gJ3N3YXBFeGFjdFRva2Vuc0ZvckVUSFN1cHBvcnRpbmdGZWVPblRyYW5zZmVyVG9rZW5zJyA6ICdzd2FwRXhhY3RUb2tlbnNGb3JFVEgnOyAvLyAodWludCBhbW91bnRJbiwgdWludCBhbW91bnRPdXRNaW4sIGFkZHJlc3NbXSBjYWxsZGF0YSBwYXRoLCBhZGRyZXNzIHRvLCB1aW50IGRlYWRsaW5lKVxuXG4gICAgICAgICAgYXJncyA9IFthbW91bnRJbiwgYW1vdW50T3V0LCBwYXRoLCB0bywgZGVhZGxpbmVdO1xuICAgICAgICAgIHZhbHVlID0gWkVST19IRVg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kTmFtZSA9IHVzZUZlZU9uVHJhbnNmZXIgPyAnc3dhcEV4YWN0VG9rZW5zRm9yVG9rZW5zU3VwcG9ydGluZ0ZlZU9uVHJhbnNmZXJUb2tlbnMnIDogJ3N3YXBFeGFjdFRva2Vuc0ZvclRva2Vucyc7IC8vICh1aW50IGFtb3VudEluLCB1aW50IGFtb3VudE91dE1pbiwgYWRkcmVzc1tdIGNhbGxkYXRhIHBhdGgsIGFkZHJlc3MgdG8sIHVpbnQgZGVhZGxpbmUpXG5cbiAgICAgICAgICBhcmdzID0gW2Ftb3VudEluLCBhbW91bnRPdXQsIHBhdGgsIHRvLCBkZWFkbGluZV07XG4gICAgICAgICAgdmFsdWUgPSBaRVJPX0hFWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRyYWRlVHlwZS5FWEFDVF9PVVRQVVQ6XG4gICAgICAgICEhdXNlRmVlT25UcmFuc2ZlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0VYQUNUX09VVF9GT1QnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGV0aGVySW4pIHtcbiAgICAgICAgICBtZXRob2ROYW1lID0gJ3N3YXBFVEhGb3JFeGFjdFRva2Vucyc7IC8vICh1aW50IGFtb3VudE91dCwgYWRkcmVzc1tdIGNhbGxkYXRhIHBhdGgsIGFkZHJlc3MgdG8sIHVpbnQgZGVhZGxpbmUpXG5cbiAgICAgICAgICBhcmdzID0gW2Ftb3VudE91dCwgcGF0aCwgdG8sIGRlYWRsaW5lXTtcbiAgICAgICAgICB2YWx1ZSA9IGFtb3VudEluO1xuICAgICAgICB9IGVsc2UgaWYgKGV0aGVyT3V0KSB7XG4gICAgICAgICAgbWV0aG9kTmFtZSA9ICdzd2FwVG9rZW5zRm9yRXhhY3RFVEgnOyAvLyAodWludCBhbW91bnRPdXQsIHVpbnQgYW1vdW50SW5NYXgsIGFkZHJlc3NbXSBjYWxsZGF0YSBwYXRoLCBhZGRyZXNzIHRvLCB1aW50IGRlYWRsaW5lKVxuXG4gICAgICAgICAgYXJncyA9IFthbW91bnRPdXQsIGFtb3VudEluLCBwYXRoLCB0bywgZGVhZGxpbmVdO1xuICAgICAgICAgIHZhbHVlID0gWkVST19IRVg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kTmFtZSA9ICdzd2FwVG9rZW5zRm9yRXhhY3RUb2tlbnMnOyAvLyAodWludCBhbW91bnRPdXQsIHVpbnQgYW1vdW50SW5NYXgsIGFkZHJlc3NbXSBjYWxsZGF0YSBwYXRoLCBhZGRyZXNzIHRvLCB1aW50IGRlYWRsaW5lKVxuXG4gICAgICAgICAgYXJncyA9IFthbW91bnRPdXQsIGFtb3VudEluLCBwYXRoLCB0bywgZGVhZGxpbmVdO1xuICAgICAgICAgIHZhbHVlID0gWkVST19IRVg7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KCk7XG5cbmV4cG9ydCB7IEZBQ1RPUllfQUREUkVTUywgSU5JVF9DT0RFX0hBU0gsIEluc3VmZmljaWVudElucHV0QW1vdW50RXJyb3IsIEluc3VmZmljaWVudFJlc2VydmVzRXJyb3IsIE1JTklNVU1fTElRVUlESVRZLCBQYWlyLCBSb3V0ZSwgUm91dGVyLCBUcmFkZSwgY29tcHV0ZVBhaXJBZGRyZXNzLCBpbnB1dE91dHB1dENvbXBhcmF0b3IsIHRyYWRlQ29tcGFyYXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9djItc2RrLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@uniswap/v2-sdk/dist/v2-sdk.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@uniswap/v2-sdk/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@uniswap/v2-sdk/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CurrencyAmount: () => (/* binding */ CurrencyAmount),\n/* harmony export */   Ether: () => (/* binding */ Ether),\n/* harmony export */   Fraction: () => (/* binding */ Fraction),\n/* harmony export */   MaxUint256: () => (/* binding */ MaxUint256),\n/* harmony export */   NativeCurrency: () => (/* binding */ NativeCurrency),\n/* harmony export */   Percent: () => (/* binding */ Percent),\n/* harmony export */   Price: () => (/* binding */ Price),\n/* harmony export */   Rounding: () => (/* binding */ Rounding),\n/* harmony export */   SupportedChainId: () => (/* binding */ SupportedChainId),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TradeType: () => (/* binding */ TradeType),\n/* harmony export */   WETH9: () => (/* binding */ WETH9),\n/* harmony export */   computePriceImpact: () => (/* binding */ computePriceImpact),\n/* harmony export */   sortedInsert: () => (/* binding */ sortedInsert),\n/* harmony export */   sqrt: () => (/* binding */ sqrt),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress)\n/* harmony export */ });\n/* harmony import */ var jsbi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsbi */ \"(ssr)/./node_modules/jsbi/dist/jsbi.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var decimal_js_light__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! decimal.js-light */ \"(ssr)/./node_modules/decimal.js-light/decimal.mjs\");\n/* harmony import */ var big_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! big.js */ \"(ssr)/./node_modules/big.js/big.mjs\");\n/* harmony import */ var toformat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! toformat */ \"(ssr)/./node_modules/toformat/toFormat.js\");\n/* harmony import */ var toformat__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(toformat__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\n\n\n\n\n\n\n\nvar SupportedChainId;\n\n(function (SupportedChainId) {\n  SupportedChainId[SupportedChainId[\"MAINNET\"] = 1] = \"MAINNET\";\n  SupportedChainId[SupportedChainId[\"GOERLI\"] = 5] = \"GOERLI\";\n  SupportedChainId[SupportedChainId[\"SEPOLIA\"] = 11155111] = \"SEPOLIA\";\n  SupportedChainId[SupportedChainId[\"ARBITRUM_ONE\"] = 42161] = \"ARBITRUM_ONE\";\n  SupportedChainId[SupportedChainId[\"ARBITRUM_GOERLI\"] = 421613] = \"ARBITRUM_GOERLI\";\n  SupportedChainId[SupportedChainId[\"OPTIMISM\"] = 10] = \"OPTIMISM\";\n  SupportedChainId[SupportedChainId[\"OPTIMISM_GOERLI\"] = 420] = \"OPTIMISM_GOERLI\";\n  SupportedChainId[SupportedChainId[\"POLYGON\"] = 137] = \"POLYGON\";\n  SupportedChainId[SupportedChainId[\"POLYGON_MUMBAI\"] = 80001] = \"POLYGON_MUMBAI\";\n  SupportedChainId[SupportedChainId[\"CELO\"] = 42220] = \"CELO\";\n  SupportedChainId[SupportedChainId[\"CELO_ALFAJORES\"] = 44787] = \"CELO_ALFAJORES\";\n  SupportedChainId[SupportedChainId[\"BNB\"] = 56] = \"BNB\";\n})(SupportedChainId || (SupportedChainId = {}));\n\nvar TradeType;\n\n(function (TradeType) {\n  TradeType[TradeType[\"EXACT_INPUT\"] = 0] = \"EXACT_INPUT\";\n  TradeType[TradeType[\"EXACT_OUTPUT\"] = 1] = \"EXACT_OUTPUT\";\n})(TradeType || (TradeType = {}));\n\nvar Rounding;\n\n(function (Rounding) {\n  Rounding[Rounding[\"ROUND_DOWN\"] = 0] = \"ROUND_DOWN\";\n  Rounding[Rounding[\"ROUND_HALF_UP\"] = 1] = \"ROUND_HALF_UP\";\n  Rounding[Rounding[\"ROUND_UP\"] = 2] = \"ROUND_UP\";\n})(Rounding || (Rounding = {}));\n\nvar MaxUint256 = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar _toSignificantRoundin, _toFixedRounding;\nvar Decimal = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(decimal_js_light__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\nvar Big = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(big_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvar toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);\nvar toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);\nvar Fraction = /*#__PURE__*/function () {\n  function Fraction(numerator, denominator) {\n    if (denominator === void 0) {\n      denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1);\n    }\n\n    this.numerator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(numerator);\n    this.denominator = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(denominator);\n  }\n\n  Fraction.tryParseFraction = function tryParseFraction(fractionish) {\n    if (fractionish instanceof jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"] || typeof fractionish === 'number' || typeof fractionish === 'string') return new Fraction(fractionish);\n    if ('numerator' in fractionish && 'denominator' in fractionish) return fractionish;\n    throw new Error('Could not parse fraction');\n  } // performs floor division\n  ;\n\n  var _proto = Fraction.prototype;\n\n  _proto.invert = function invert() {\n    return new Fraction(this.denominator, this.numerator);\n  };\n\n  _proto.add = function add(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.numerator, otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.subtract = function subtract(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n\n    if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract(this.numerator, otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtract(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.lessThan = function lessThan(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.equalTo = function equalTo(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].equal(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.greaterThan = function greaterThan(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThan(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(otherParsed.numerator, this.denominator));\n  };\n\n  _proto.multiply = function multiply(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.numerator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.denominator));\n  };\n\n  _proto.divide = function divide(other) {\n    var otherParsed = Fraction.tryParseFraction(other);\n    return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.numerator, otherParsed.denominator), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].multiply(this.denominator, otherParsed.numerator));\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n\n    !Number.isInteger(significantDigits) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, significantDigits + \" is not an integer.\") : 0 : void 0;\n    !(significantDigits > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, significantDigits + \" is not positive.\") : 0 : void 0;\n    Decimal.set({\n      precision: significantDigits + 1,\n      rounding: toSignificantRounding[rounding]\n    });\n    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);\n    return quotient.toFormat(quotient.decimalPlaces(), format);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n\n    !Number.isInteger(decimalPlaces) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, decimalPlaces + \" is not an integer.\") : 0 : void 0;\n    !(decimalPlaces >= 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, decimalPlaces + \" is negative.\") : 0 : void 0;\n    Big.DP = decimalPlaces;\n    Big.RM = toFixedRounding[rounding];\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);\n  }\n  /**\r\n   * Helper method for converting any super class back to a fraction\r\n   */\n  ;\n\n  _createClass(Fraction, [{\n    key: \"quotient\",\n    get: function get() {\n      return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(this.numerator, this.denominator);\n    } // remainder after floor division\n\n  }, {\n    key: \"remainder\",\n    get: function get() {\n      return new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remainder(this.numerator, this.denominator), this.denominator);\n    }\n  }, {\n    key: \"asFraction\",\n    get: function get() {\n      return new Fraction(this.numerator, this.denominator);\n    }\n  }]);\n\n  return Fraction;\n}();\n\nvar Big$1 = /*#__PURE__*/toformat__WEBPACK_IMPORTED_MODULE_4___default()(big_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nvar CurrencyAmount = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(CurrencyAmount, _Fraction);\n\n  function CurrencyAmount(currency, numerator, denominator) {\n    var _this;\n\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    !jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThanOrEqual(_this.quotient, MaxUint256) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'AMOUNT') : 0 : void 0;\n    _this.currency = currency;\n    _this.decimalScale = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(currency.decimals));\n    return _this;\n  }\n  /**\r\n   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount\r\n   * @param currency the currency in the amount\r\n   * @param rawAmount the raw token or ether amount\r\n   */\n\n\n  CurrencyAmount.fromRawAmount = function fromRawAmount(currency, rawAmount) {\n    return new CurrencyAmount(currency, rawAmount);\n  }\n  /**\r\n   * Construct a currency amount with a denominator that is not equal to 1\r\n   * @param currency the currency\r\n   * @param numerator the numerator of the fractional token amount\r\n   * @param denominator the denominator of the fractional token amount\r\n   */\n  ;\n\n  CurrencyAmount.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {\n    return new CurrencyAmount(currency, numerator, denominator);\n  };\n\n  var _proto = CurrencyAmount.prototype;\n\n  _proto.add = function add(other) {\n    !this.currency.equals(other.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CURRENCY') : 0 : void 0;\n\n    var added = _Fraction.prototype.add.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator);\n  };\n\n  _proto.subtract = function subtract(other) {\n    !this.currency.equals(other.currency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CURRENCY') : 0 : void 0;\n\n    var subtracted = _Fraction.prototype.subtract.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);\n  };\n\n  _proto.multiply = function multiply(other) {\n    var multiplied = _Fraction.prototype.multiply.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);\n  };\n\n  _proto.divide = function divide(other) {\n    var divided = _Fraction.prototype.divide.call(this, other);\n\n    return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n\n    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = this.currency.decimals;\n    }\n\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n\n    !(decimalPlaces <= this.currency.decimals) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'DECIMALS') : 0 : void 0;\n    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);\n  };\n\n  _proto.toExact = function toExact(format) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n\n    Big$1.DP = this.currency.decimals;\n    return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);\n  };\n\n  _createClass(CurrencyAmount, [{\n    key: \"wrapped\",\n    get: function get() {\n      if (this.currency.isToken) return this;\n      return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);\n    }\n  }]);\n\n  return CurrencyAmount;\n}(Fraction);\n\nvar ONE_HUNDRED = /*#__PURE__*/new Fraction( /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(100));\n/**\r\n * Converts a fraction to a percent\r\n * @param fraction the fraction to convert\r\n */\n\nfunction toPercent(fraction) {\n  return new Percent(fraction.numerator, fraction.denominator);\n}\n\nvar Percent = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Percent, _Fraction);\n\n  function Percent() {\n    var _this;\n\n    _this = _Fraction.apply(this, arguments) || this;\n    /**\r\n     * This boolean prevents a fraction from being interpreted as a Percent\r\n     */\n\n    _this.isPercent = true;\n    return _this;\n  }\n\n  var _proto = Percent.prototype;\n\n  _proto.add = function add(other) {\n    return toPercent(_Fraction.prototype.add.call(this, other));\n  };\n\n  _proto.subtract = function subtract(other) {\n    return toPercent(_Fraction.prototype.subtract.call(this, other));\n  };\n\n  _proto.multiply = function multiply(other) {\n    return toPercent(_Fraction.prototype.multiply.call(this, other));\n  };\n\n  _proto.divide = function divide(other) {\n    return toPercent(_Fraction.prototype.divide.call(this, other));\n  };\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 5;\n    }\n\n    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 2;\n    }\n\n    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);\n  };\n\n  return Percent;\n}(Fraction);\n\nvar Price = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Price, _Fraction);\n\n  /**\r\n   * Construct a price, either with the base and quote currency amount, or the\r\n   * @param args\r\n   */\n  function Price() {\n    var _this;\n\n    var baseCurrency, quoteCurrency, denominator, numerator;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 4) {\n      baseCurrency = args[0];\n      quoteCurrency = args[1];\n      denominator = args[2];\n      numerator = args[3];\n    } else {\n      var result = args[0].quoteAmount.divide(args[0].baseAmount);\n      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];\n      baseCurrency = _ref[0];\n      quoteCurrency = _ref[1];\n      denominator = _ref[2];\n      numerator = _ref[3];\n    }\n\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    _this.baseCurrency = baseCurrency;\n    _this.quoteCurrency = quoteCurrency;\n    _this.scalar = new Fraction(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(baseCurrency.decimals)), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentiate(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(10), jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(quoteCurrency.decimals)));\n    return _this;\n  }\n  /**\r\n   * Flip the price, switching the base and quote currency\r\n   */\n\n\n  var _proto = Price.prototype;\n\n  _proto.invert = function invert() {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);\n  }\n  /**\r\n   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency\r\n   * @param other the other price\r\n   */\n  ;\n\n  _proto.multiply = function multiply(other) {\n    !this.quoteCurrency.equals(other.baseCurrency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    var fraction = _Fraction.prototype.multiply.call(this, other);\n\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);\n  }\n  /**\r\n   * Return the amount of quote currency corresponding to a given amount of the base currency\r\n   * @param currencyAmount the amount of base currency to quote against the price\r\n   */\n  ;\n\n  _proto.quote = function quote(currencyAmount) {\n    !currencyAmount.currency.equals(this.baseCurrency) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'TOKEN') : 0 : void 0;\n\n    var result = _Fraction.prototype.multiply.call(this, currencyAmount);\n\n    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);\n  }\n  /**\r\n   * Get the value scaled by decimals for formatting\r\n   * @private\r\n   */\n  ;\n\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n\n    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);\n  };\n\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 4;\n    }\n\n    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);\n  };\n\n  _createClass(Price, [{\n    key: \"adjustedForDecimals\",\n    get: function get() {\n      return _Fraction.prototype.multiply.call(this, this.scalar);\n    }\n  }]);\n\n  return Price;\n}(Fraction);\n\n/**\r\n * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies\r\n */\n\nvar BaseCurrency =\n/**\r\n * Constructs an instance of the base class `BaseCurrency`.\r\n * @param chainId the chain ID on which this currency resides\r\n * @param decimals decimals of the currency\r\n * @param symbol symbol of the currency\r\n * @param name of the currency\r\n */\nfunction BaseCurrency(chainId, decimals, symbol, name) {\n  !Number.isSafeInteger(chainId) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CHAIN_ID') : 0 : void 0;\n  !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'DECIMALS') : 0 : void 0;\n  this.chainId = chainId;\n  this.decimals = decimals;\n  this.symbol = symbol;\n  this.name = name;\n};\n\n/**\r\n * Represents the native currency of the chain on which it resides, e.g.\r\n */\n\nvar NativeCurrency = /*#__PURE__*/function (_BaseCurrency) {\n  _inheritsLoose(NativeCurrency, _BaseCurrency);\n\n  function NativeCurrency() {\n    var _this;\n\n    _this = _BaseCurrency.apply(this, arguments) || this;\n    _this.isNative = true;\n    _this.isToken = false;\n    return _this;\n  }\n\n  return NativeCurrency;\n}(BaseCurrency);\n\n/**\r\n * Validates an address and returns the parsed (checksummed) version of that address\r\n * @param address the unchecksummed hex address\r\n */\n\nfunction validateAndParseAddress(address) {\n  try {\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_5__.getAddress)(address);\n  } catch (error) {\n    throw new Error(address + \" is not a valid address.\");\n  }\n} // Checks a string starts with 0x, is 42 characters long and contains only hex characters after 0x\n\nvar startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;\n/**\r\n * Checks if an address is valid by checking 0x prefix, length === 42 and hex encoding.\r\n * @param address the unchecksummed hex address\r\n */\n\nfunction checkValidAddress(address) {\n  if (startsWith0xLen42HexRegex.test(address)) {\n    return address;\n  }\n\n  throw new Error(address + \" is not a valid address.\");\n}\n\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\n\nvar Token = /*#__PURE__*/function (_BaseCurrency) {\n  _inheritsLoose(Token, _BaseCurrency);\n\n  /**\r\n   *\r\n   * @param chainId {@link BaseCurrency#chainId}\r\n   * @param address The contract address on the chain on which this token lives\r\n   * @param decimals {@link BaseCurrency#decimals}\r\n   * @param symbol {@link BaseCurrency#symbol}\r\n   * @param name {@link BaseCurrency#name}\r\n   * @param bypassChecksum If true it only checks for length === 42, startsWith 0x and contains only hex characters\r\n   */\n  function Token(chainId, address, decimals, symbol, name, bypassChecksum) {\n    var _this;\n\n    _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;\n    _this.isNative = false;\n    _this.isToken = true;\n\n    if (bypassChecksum) {\n      _this.address = checkValidAddress(address);\n    } else {\n      _this.address = validateAndParseAddress(address);\n    }\n\n    return _this;\n  }\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\n\n\n  var _proto = Token.prototype;\n\n  _proto.equals = function equals(other) {\n    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();\n  }\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */\n  ;\n\n  _proto.sortsBefore = function sortsBefore(other) {\n    !(this.chainId === other.chainId) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'CHAIN_IDS') : 0 : void 0;\n    !(this.address.toLowerCase() !== other.address.toLowerCase()) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'ADDRESSES') : 0 : void 0;\n    return this.address.toLowerCase() < other.address.toLowerCase();\n  }\n  /**\r\n   * Return this token, which does not need to be wrapped\r\n   */\n  ;\n\n  _createClass(Token, [{\n    key: \"wrapped\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return Token;\n}(BaseCurrency);\n\nvar _WETH;\n/**\r\n * Known WETH9 implementation addresses, used in our implementation of Ether#wrapped\r\n */\n\nvar WETH9 = (_WETH = {}, _WETH[1] = /*#__PURE__*/new Token(1, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH', 'Wrapped Ether'), _WETH[3] = /*#__PURE__*/new Token(3, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[4] = /*#__PURE__*/new Token(4, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'), _WETH[5] = /*#__PURE__*/new Token(5, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'), _WETH[42] = /*#__PURE__*/new Token(42, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether'), _WETH[10] = /*#__PURE__*/new Token(10, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[69] = /*#__PURE__*/new Token(69, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'), _WETH[42161] = /*#__PURE__*/new Token(42161, '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1', 18, 'WETH', 'Wrapped Ether'), _WETH[421611] = /*#__PURE__*/new Token(421611, '0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681', 18, 'WETH', 'Wrapped Ether'), _WETH);\n\n/**\r\n * Ether is the main usage of a 'native' currency, i.e. for Ethereum mainnet and all testnets\r\n */\n\nvar Ether = /*#__PURE__*/function (_NativeCurrency) {\n  _inheritsLoose(Ether, _NativeCurrency);\n\n  function Ether(chainId) {\n    return _NativeCurrency.call(this, chainId, 18, 'ETH', 'Ether') || this;\n  }\n\n  Ether.onChain = function onChain(chainId) {\n    var _this$_etherCache$cha;\n\n    return (_this$_etherCache$cha = this._etherCache[chainId]) != null ? _this$_etherCache$cha : this._etherCache[chainId] = new Ether(chainId);\n  };\n\n  var _proto = Ether.prototype;\n\n  _proto.equals = function equals(other) {\n    return other.isNative && other.chainId === this.chainId;\n  };\n\n  _createClass(Ether, [{\n    key: \"wrapped\",\n    get: function get() {\n      var weth9 = WETH9[this.chainId];\n      !!!weth9 ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'WRAPPED') : 0 : void 0;\n      return weth9;\n    }\n  }]);\n\n  return Ether;\n}(NativeCurrency);\nEther._etherCache = {};\n\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\n\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\n  var quotedOutputAmount = midPrice.quote(inputAmount); // calculate price impact := (exactQuote - outputAmount) / exactQuote\n\n  var priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);\n  return new Percent(priceImpact.numerator, priceImpact.denominator);\n}\n\n// `maxSize` by removing the last item\n\nfunction sortedInsert(items, add, maxSize, comparator) {\n  !(maxSize > 0) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'MAX_SIZE_ZERO') : 0 : void 0; // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n\n  !(items.length <= maxSize) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'ITEMS_SIZE') : 0 : void 0; // short circuit first item add\n\n  if (items.length === 0) {\n    items.push(add);\n    return null;\n  } else {\n    var isFull = items.length === maxSize; // short circuit if full and the additional item does not come before the last item\n\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add;\n    }\n\n    var lo = 0,\n        hi = items.length;\n\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n\n    items.splice(lo, 0, add);\n    return isFull ? items.pop() : null;\n  }\n}\n\nvar MAX_SAFE_INTEGER = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(Number.MAX_SAFE_INTEGER);\nvar ZERO = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(0);\nvar ONE = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(1);\nvar TWO = /*#__PURE__*/jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(2);\n/**\r\n * Computes floor(sqrt(value))\r\n * @param value the value for which to compute the square root, rounded down\r\n */\n\nfunction sqrt(value) {\n  !jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].greaterThanOrEqual(value, ZERO) ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(false, 'NEGATIVE') : 0 : void 0; // rely on built in sqrt if possible\n\n  if (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(value, MAX_SAFE_INTEGER)) {\n    return jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].BigInt(Math.floor(Math.sqrt(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toNumber(value))));\n  }\n\n  var z;\n  var x;\n  z = value;\n  x = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(value, TWO), ONE);\n\n  while (jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lessThan(x, z)) {\n    z = x;\n    x = jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(jsbi__WEBPACK_IMPORTED_MODULE_0__[\"default\"].divide(value, x), x), TWO);\n  }\n\n  return z;\n}\n\n\n//# sourceMappingURL=sdk-core.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVuaXN3YXAvdjItc2RrL25vZGVfbW9kdWxlcy9AdW5pc3dhcC9zZGstY29yZS9kaXN0L3Nkay1jb3JlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNlO0FBQ0M7QUFDZDtBQUNNO0FBQ29COztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7QUFFN0IsOEJBQThCLDRDQUFJOztBQUVsQztBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLCtDQUFRLENBQUMsd0RBQVE7QUFDNUMsdUJBQXVCLCtDQUFRLENBQUMsOENBQUk7QUFDcEMsdURBQXVEO0FBQ3ZELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUk7QUFDeEI7O0FBRUEscUJBQXFCLDRDQUFJO0FBQ3pCLHVCQUF1Qiw0Q0FBSTtBQUMzQjs7QUFFQTtBQUNBLCtCQUErQiw0Q0FBSTtBQUNuQztBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsNENBQUk7QUFDWiwwQkFBMEIsNENBQUk7QUFDOUI7O0FBRUEsd0JBQXdCLDRDQUFJLEtBQUssNENBQUksb0RBQW9ELDRDQUFJLHFEQUFxRCw0Q0FBSTtBQUN0Sjs7QUFFQTtBQUNBOztBQUVBLFFBQVEsNENBQUk7QUFDWiwwQkFBMEIsNENBQUk7QUFD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QXdCLENBQWdCLFdBQVc7O0FBRW5JO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLDRDQUFJO0FBQ3hDLHdCQUF3Qiw0Q0FBSTtBQUM1Qix1QkFBdUIsNENBQUk7QUFDM0IsdUJBQXVCLDRDQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyw0Q0FBSSxtQ0FBbUMsS0FBcUMsR0FBRywwREFBUyxzQkFBc0IsQ0FBZ0IsV0FBVzs7QUFFNUksTUFBTSw0Q0FBSTtBQUNWLFdBQVcsNENBQUksNkJBQTZCLDRDQUFJO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQUksS0FBSyw0Q0FBSTs7QUFFbkIsU0FBUyw0Q0FBSTtBQUNiO0FBQ0EsUUFBUSw0Q0FBSSxRQUFRLDRDQUFJLEtBQUssNENBQUk7QUFDakM7O0FBRUE7QUFDQTs7QUFFNk07QUFDN00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac2UtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvQHVuaXN3YXAvdjItc2RrL25vZGVfbW9kdWxlcy9AdW5pc3dhcC9zZGstY29yZS9kaXN0L3Nkay1jb3JlLmVzbS5qcz9lZWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBKU0JJIGZyb20gJ2pzYmknO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgX0RlY2ltYWwgZnJvbSAnZGVjaW1hbC5qcy1saWdodCc7XG5pbXBvcnQgX0JpZyBmcm9tICdiaWcuanMnO1xuaW1wb3J0IHRvRm9ybWF0IGZyb20gJ3RvZm9ybWF0JztcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9hZGRyZXNzJztcblxudmFyIFN1cHBvcnRlZENoYWluSWQ7XG5cbihmdW5jdGlvbiAoU3VwcG9ydGVkQ2hhaW5JZCkge1xuICBTdXBwb3J0ZWRDaGFpbklkW1N1cHBvcnRlZENoYWluSWRbXCJNQUlOTkVUXCJdID0gMV0gPSBcIk1BSU5ORVRcIjtcbiAgU3VwcG9ydGVkQ2hhaW5JZFtTdXBwb3J0ZWRDaGFpbklkW1wiR09FUkxJXCJdID0gNV0gPSBcIkdPRVJMSVwiO1xuICBTdXBwb3J0ZWRDaGFpbklkW1N1cHBvcnRlZENoYWluSWRbXCJTRVBPTElBXCJdID0gMTExNTUxMTFdID0gXCJTRVBPTElBXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIkFSQklUUlVNX09ORVwiXSA9IDQyMTYxXSA9IFwiQVJCSVRSVU1fT05FXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIkFSQklUUlVNX0dPRVJMSVwiXSA9IDQyMTYxM10gPSBcIkFSQklUUlVNX0dPRVJMSVwiO1xuICBTdXBwb3J0ZWRDaGFpbklkW1N1cHBvcnRlZENoYWluSWRbXCJPUFRJTUlTTVwiXSA9IDEwXSA9IFwiT1BUSU1JU01cIjtcbiAgU3VwcG9ydGVkQ2hhaW5JZFtTdXBwb3J0ZWRDaGFpbklkW1wiT1BUSU1JU01fR09FUkxJXCJdID0gNDIwXSA9IFwiT1BUSU1JU01fR09FUkxJXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIlBPTFlHT05cIl0gPSAxMzddID0gXCJQT0xZR09OXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIlBPTFlHT05fTVVNQkFJXCJdID0gODAwMDFdID0gXCJQT0xZR09OX01VTUJBSVwiO1xuICBTdXBwb3J0ZWRDaGFpbklkW1N1cHBvcnRlZENoYWluSWRbXCJDRUxPXCJdID0gNDIyMjBdID0gXCJDRUxPXCI7XG4gIFN1cHBvcnRlZENoYWluSWRbU3VwcG9ydGVkQ2hhaW5JZFtcIkNFTE9fQUxGQUpPUkVTXCJdID0gNDQ3ODddID0gXCJDRUxPX0FMRkFKT1JFU1wiO1xuICBTdXBwb3J0ZWRDaGFpbklkW1N1cHBvcnRlZENoYWluSWRbXCJCTkJcIl0gPSA1Nl0gPSBcIkJOQlwiO1xufSkoU3VwcG9ydGVkQ2hhaW5JZCB8fCAoU3VwcG9ydGVkQ2hhaW5JZCA9IHt9KSk7XG5cbnZhciBUcmFkZVR5cGU7XG5cbihmdW5jdGlvbiAoVHJhZGVUeXBlKSB7XG4gIFRyYWRlVHlwZVtUcmFkZVR5cGVbXCJFWEFDVF9JTlBVVFwiXSA9IDBdID0gXCJFWEFDVF9JTlBVVFwiO1xuICBUcmFkZVR5cGVbVHJhZGVUeXBlW1wiRVhBQ1RfT1VUUFVUXCJdID0gMV0gPSBcIkVYQUNUX09VVFBVVFwiO1xufSkoVHJhZGVUeXBlIHx8IChUcmFkZVR5cGUgPSB7fSkpO1xuXG52YXIgUm91bmRpbmc7XG5cbihmdW5jdGlvbiAoUm91bmRpbmcpIHtcbiAgUm91bmRpbmdbUm91bmRpbmdbXCJST1VORF9ET1dOXCJdID0gMF0gPSBcIlJPVU5EX0RPV05cIjtcbiAgUm91bmRpbmdbUm91bmRpbmdbXCJST1VORF9IQUxGX1VQXCJdID0gMV0gPSBcIlJPVU5EX0hBTEZfVVBcIjtcbiAgUm91bmRpbmdbUm91bmRpbmdbXCJST1VORF9VUFwiXSA9IDJdID0gXCJST1VORF9VUFwiO1xufSkoUm91bmRpbmcgfHwgKFJvdW5kaW5nID0ge30pKTtcblxudmFyIE1heFVpbnQyNTYgPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIF90b1NpZ25pZmljYW50Um91bmRpbiwgX3RvRml4ZWRSb3VuZGluZztcbnZhciBEZWNpbWFsID0gLyojX19QVVJFX18qL3RvRm9ybWF0KF9EZWNpbWFsKTtcbnZhciBCaWcgPSAvKiNfX1BVUkVfXyovdG9Gb3JtYXQoX0JpZyk7XG52YXIgdG9TaWduaWZpY2FudFJvdW5kaW5nID0gKF90b1NpZ25pZmljYW50Um91bmRpbiA9IHt9LCBfdG9TaWduaWZpY2FudFJvdW5kaW5bUm91bmRpbmcuUk9VTkRfRE9XTl0gPSBEZWNpbWFsLlJPVU5EX0RPV04sIF90b1NpZ25pZmljYW50Um91bmRpbltSb3VuZGluZy5ST1VORF9IQUxGX1VQXSA9IERlY2ltYWwuUk9VTkRfSEFMRl9VUCwgX3RvU2lnbmlmaWNhbnRSb3VuZGluW1JvdW5kaW5nLlJPVU5EX1VQXSA9IERlY2ltYWwuUk9VTkRfVVAsIF90b1NpZ25pZmljYW50Um91bmRpbik7XG52YXIgdG9GaXhlZFJvdW5kaW5nID0gKF90b0ZpeGVkUm91bmRpbmcgPSB7fSwgX3RvRml4ZWRSb3VuZGluZ1tSb3VuZGluZy5ST1VORF9ET1dOXSA9IDAsIF90b0ZpeGVkUm91bmRpbmdbUm91bmRpbmcuUk9VTkRfSEFMRl9VUF0gPSAxLCBfdG9GaXhlZFJvdW5kaW5nW1JvdW5kaW5nLlJPVU5EX1VQXSA9IDMsIF90b0ZpeGVkUm91bmRpbmcpO1xudmFyIEZyYWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhY3Rpb24obnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIGlmIChkZW5vbWluYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgICBkZW5vbWluYXRvciA9IEpTQkkuQmlnSW50KDEpO1xuICAgIH1cblxuICAgIHRoaXMubnVtZXJhdG9yID0gSlNCSS5CaWdJbnQobnVtZXJhdG9yKTtcbiAgICB0aGlzLmRlbm9taW5hdG9yID0gSlNCSS5CaWdJbnQoZGVub21pbmF0b3IpO1xuICB9XG5cbiAgRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbiA9IGZ1bmN0aW9uIHRyeVBhcnNlRnJhY3Rpb24oZnJhY3Rpb25pc2gpIHtcbiAgICBpZiAoZnJhY3Rpb25pc2ggaW5zdGFuY2VvZiBKU0JJIHx8IHR5cGVvZiBmcmFjdGlvbmlzaCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGZyYWN0aW9uaXNoID09PSAnc3RyaW5nJykgcmV0dXJuIG5ldyBGcmFjdGlvbihmcmFjdGlvbmlzaCk7XG4gICAgaWYgKCdudW1lcmF0b3InIGluIGZyYWN0aW9uaXNoICYmICdkZW5vbWluYXRvcicgaW4gZnJhY3Rpb25pc2gpIHJldHVybiBmcmFjdGlvbmlzaDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBmcmFjdGlvbicpO1xuICB9IC8vIHBlcmZvcm1zIGZsb29yIGRpdmlzaW9uXG4gIDtcblxuICB2YXIgX3Byb3RvID0gRnJhY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgcmV0dXJuIG5ldyBGcmFjdGlvbih0aGlzLmRlbm9taW5hdG9yLCB0aGlzLm51bWVyYXRvcik7XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuXG4gICAgaWYgKEpTQkkuZXF1YWwodGhpcy5kZW5vbWluYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpKSB7XG4gICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkuYWRkKHRoaXMubnVtZXJhdG9yLCBvdGhlclBhcnNlZC5udW1lcmF0b3IpLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkuYWRkKEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseShvdGhlclBhcnNlZC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpKSwgSlNCSS5tdWx0aXBseSh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgdmFyIG90aGVyUGFyc2VkID0gRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbihvdGhlcik7XG5cbiAgICBpZiAoSlNCSS5lcXVhbCh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpIHtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24oSlNCSS5zdWJ0cmFjdCh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQubnVtZXJhdG9yKSwgdGhpcy5kZW5vbWluYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBGcmFjdGlvbihKU0JJLnN1YnRyYWN0KEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseShvdGhlclBhcnNlZC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpKSwgSlNCSS5tdWx0aXBseSh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XG4gICAgdmFyIG90aGVyUGFyc2VkID0gRnJhY3Rpb24udHJ5UGFyc2VGcmFjdGlvbihvdGhlcik7XG4gICAgcmV0dXJuIEpTQkkubGVzc1RoYW4oSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQuZGVub21pbmF0b3IpLCBKU0JJLm11bHRpcGx5KG90aGVyUGFyc2VkLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbFRvID0gZnVuY3Rpb24gZXF1YWxUbyhvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuICAgIHJldHVybiBKU0JJLmVxdWFsKEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseShvdGhlclBhcnNlZC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpKTtcbiAgfTtcblxuICBfcHJvdG8uZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuICAgIHJldHVybiBKU0JJLmdyZWF0ZXJUaGFuKEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseShvdGhlclBhcnNlZC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpKTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShvdGhlcikge1xuICAgIHZhciBvdGhlclBhcnNlZCA9IEZyYWN0aW9uLnRyeVBhcnNlRnJhY3Rpb24ob3RoZXIpO1xuICAgIHJldHVybiBuZXcgRnJhY3Rpb24oSlNCSS5tdWx0aXBseSh0aGlzLm51bWVyYXRvciwgb3RoZXJQYXJzZWQubnVtZXJhdG9yKSwgSlNCSS5tdWx0aXBseSh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5kZW5vbWluYXRvcikpO1xuICB9O1xuXG4gIF9wcm90by5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUob3RoZXIpIHtcbiAgICB2YXIgb3RoZXJQYXJzZWQgPSBGcmFjdGlvbi50cnlQYXJzZUZyYWN0aW9uKG90aGVyKTtcbiAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkubXVsdGlwbHkodGhpcy5udW1lcmF0b3IsIG90aGVyUGFyc2VkLmRlbm9taW5hdG9yKSwgSlNCSS5tdWx0aXBseSh0aGlzLmRlbm9taW5hdG9yLCBvdGhlclBhcnNlZC5udW1lcmF0b3IpKTtcbiAgfTtcblxuICBfcHJvdG8udG9TaWduaWZpY2FudCA9IGZ1bmN0aW9uIHRvU2lnbmlmaWNhbnQoc2lnbmlmaWNhbnREaWdpdHMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdCA9IHtcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChyb3VuZGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICByb3VuZGluZyA9IFJvdW5kaW5nLlJPVU5EX0hBTEZfVVA7XG4gICAgfVxuXG4gICAgIU51bWJlci5pc0ludGVnZXIoc2lnbmlmaWNhbnREaWdpdHMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBzaWduaWZpY2FudERpZ2l0cyArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIShzaWduaWZpY2FudERpZ2l0cyA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBzaWduaWZpY2FudERpZ2l0cyArIFwiIGlzIG5vdCBwb3NpdGl2ZS5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIERlY2ltYWwuc2V0KHtcbiAgICAgIHByZWNpc2lvbjogc2lnbmlmaWNhbnREaWdpdHMgKyAxLFxuICAgICAgcm91bmRpbmc6IHRvU2lnbmlmaWNhbnRSb3VuZGluZ1tyb3VuZGluZ11cbiAgICB9KTtcbiAgICB2YXIgcXVvdGllbnQgPSBuZXcgRGVjaW1hbCh0aGlzLm51bWVyYXRvci50b1N0cmluZygpKS5kaXYodGhpcy5kZW5vbWluYXRvci50b1N0cmluZygpKS50b1NpZ25pZmljYW50RGlnaXRzKHNpZ25pZmljYW50RGlnaXRzKTtcbiAgICByZXR1cm4gcXVvdGllbnQudG9Gb3JtYXQocXVvdGllbnQuZGVjaW1hbFBsYWNlcygpLCBmb3JtYXQpO1xuICB9O1xuXG4gIF9wcm90by50b0ZpeGVkID0gZnVuY3Rpb24gdG9GaXhlZChkZWNpbWFsUGxhY2VzLCBmb3JtYXQsIHJvdW5kaW5nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXQgPSB7XG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAocm91bmRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgcm91bmRpbmcgPSBSb3VuZGluZy5ST1VORF9IQUxGX1VQO1xuICAgIH1cblxuICAgICFOdW1iZXIuaXNJbnRlZ2VyKGRlY2ltYWxQbGFjZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBkZWNpbWFsUGxhY2VzICsgXCIgaXMgbm90IGFuIGludGVnZXIuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKGRlY2ltYWxQbGFjZXMgPj0gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGRlY2ltYWxQbGFjZXMgKyBcIiBpcyBuZWdhdGl2ZS5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIEJpZy5EUCA9IGRlY2ltYWxQbGFjZXM7XG4gICAgQmlnLlJNID0gdG9GaXhlZFJvdW5kaW5nW3JvdW5kaW5nXTtcbiAgICByZXR1cm4gbmV3IEJpZyh0aGlzLm51bWVyYXRvci50b1N0cmluZygpKS5kaXYodGhpcy5kZW5vbWluYXRvci50b1N0cmluZygpKS50b0Zvcm1hdChkZWNpbWFsUGxhY2VzLCBmb3JtYXQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEhlbHBlciBtZXRob2QgZm9yIGNvbnZlcnRpbmcgYW55IHN1cGVyIGNsYXNzIGJhY2sgdG8gYSBmcmFjdGlvblxyXG4gICAqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKEZyYWN0aW9uLCBbe1xuICAgIGtleTogXCJxdW90aWVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEpTQkkuZGl2aWRlKHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9IC8vIHJlbWFpbmRlciBhZnRlciBmbG9vciBkaXZpc2lvblxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtYWluZGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbmV3IEZyYWN0aW9uKEpTQkkucmVtYWluZGVyKHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKSwgdGhpcy5kZW5vbWluYXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzRnJhY3Rpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBuZXcgRnJhY3Rpb24odGhpcy5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmFjdGlvbjtcbn0oKTtcblxudmFyIEJpZyQxID0gLyojX19QVVJFX18qL3RvRm9ybWF0KF9CaWcpO1xudmFyIEN1cnJlbmN5QW1vdW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRnJhY3Rpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoQ3VycmVuY3lBbW91bnQsIF9GcmFjdGlvbik7XG5cbiAgZnVuY3Rpb24gQ3VycmVuY3lBbW91bnQoY3VycmVuY3ksIG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9GcmFjdGlvbi5jYWxsKHRoaXMsIG51bWVyYXRvciwgZGVub21pbmF0b3IpIHx8IHRoaXM7XG4gICAgIUpTQkkubGVzc1RoYW5PckVxdWFsKF90aGlzLnF1b3RpZW50LCBNYXhVaW50MjU2KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0FNT1VOVCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBfdGhpcy5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgIF90aGlzLmRlY2ltYWxTY2FsZSA9IEpTQkkuZXhwb25lbnRpYXRlKEpTQkkuQmlnSW50KDEwKSwgSlNCSS5CaWdJbnQoY3VycmVuY3kuZGVjaW1hbHMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBjdXJyZW5jeSBhbW91bnQgaW5zdGFuY2UgZnJvbSB0aGUgdW5pdGxlc3MgYW1vdW50IG9mIHRva2VuLCBpLmUuIHRoZSByYXcgYW1vdW50XHJcbiAgICogQHBhcmFtIGN1cnJlbmN5IHRoZSBjdXJyZW5jeSBpbiB0aGUgYW1vdW50XHJcbiAgICogQHBhcmFtIHJhd0Ftb3VudCB0aGUgcmF3IHRva2VuIG9yIGV0aGVyIGFtb3VudFxyXG4gICAqL1xuXG5cbiAgQ3VycmVuY3lBbW91bnQuZnJvbVJhd0Ftb3VudCA9IGZ1bmN0aW9uIGZyb21SYXdBbW91bnQoY3VycmVuY3ksIHJhd0Ftb3VudCkge1xuICAgIHJldHVybiBuZXcgQ3VycmVuY3lBbW91bnQoY3VycmVuY3ksIHJhd0Ftb3VudCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgY3VycmVuY3kgYW1vdW50IHdpdGggYSBkZW5vbWluYXRvciB0aGF0IGlzIG5vdCBlcXVhbCB0byAxXHJcbiAgICogQHBhcmFtIGN1cnJlbmN5IHRoZSBjdXJyZW5jeVxyXG4gICAqIEBwYXJhbSBudW1lcmF0b3IgdGhlIG51bWVyYXRvciBvZiB0aGUgZnJhY3Rpb25hbCB0b2tlbiBhbW91bnRcclxuICAgKiBAcGFyYW0gZGVub21pbmF0b3IgdGhlIGRlbm9taW5hdG9yIG9mIHRoZSBmcmFjdGlvbmFsIHRva2VuIGFtb3VudFxyXG4gICAqL1xuICA7XG5cbiAgQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQgPSBmdW5jdGlvbiBmcm9tRnJhY3Rpb25hbEFtb3VudChjdXJyZW5jeSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIHJldHVybiBuZXcgQ3VycmVuY3lBbW91bnQoY3VycmVuY3ksIG51bWVyYXRvciwgZGVub21pbmF0b3IpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBDdXJyZW5jeUFtb3VudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChvdGhlcikge1xuICAgICF0aGlzLmN1cnJlbmN5LmVxdWFscyhvdGhlci5jdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDVVJSRU5DWScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBhZGRlZCA9IF9GcmFjdGlvbi5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgb3RoZXIpO1xuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHRoaXMuY3VycmVuY3ksIGFkZGVkLm51bWVyYXRvciwgYWRkZWQuZGVub21pbmF0b3IpO1xuICB9O1xuXG4gIF9wcm90by5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgIXRoaXMuY3VycmVuY3kuZXF1YWxzKG90aGVyLmN1cnJlbmN5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NVUlJFTkNZJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIHN1YnRyYWN0ZWQgPSBfRnJhY3Rpb24ucHJvdG90eXBlLnN1YnRyYWN0LmNhbGwodGhpcywgb3RoZXIpO1xuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHRoaXMuY3VycmVuY3ksIHN1YnRyYWN0ZWQubnVtZXJhdG9yLCBzdWJ0cmFjdGVkLmRlbm9taW5hdG9yKTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShvdGhlcikge1xuICAgIHZhciBtdWx0aXBsaWVkID0gX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIG90aGVyKTtcblxuICAgIHJldHVybiBDdXJyZW5jeUFtb3VudC5mcm9tRnJhY3Rpb25hbEFtb3VudCh0aGlzLmN1cnJlbmN5LCBtdWx0aXBsaWVkLm51bWVyYXRvciwgbXVsdGlwbGllZC5kZW5vbWluYXRvcik7XG4gIH07XG5cbiAgX3Byb3RvLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShvdGhlcikge1xuICAgIHZhciBkaXZpZGVkID0gX0ZyYWN0aW9uLnByb3RvdHlwZS5kaXZpZGUuY2FsbCh0aGlzLCBvdGhlcik7XG5cbiAgICByZXR1cm4gQ3VycmVuY3lBbW91bnQuZnJvbUZyYWN0aW9uYWxBbW91bnQodGhpcy5jdXJyZW5jeSwgZGl2aWRlZC5udW1lcmF0b3IsIGRpdmlkZWQuZGVub21pbmF0b3IpO1xuICB9O1xuXG4gIF9wcm90by50b1NpZ25pZmljYW50ID0gZnVuY3Rpb24gdG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDY7XG4gICAgfVxuXG4gICAgaWYgKHJvdW5kaW5nID09PSB2b2lkIDApIHtcbiAgICAgIHJvdW5kaW5nID0gUm91bmRpbmcuUk9VTkRfRE9XTjtcbiAgICB9XG5cbiAgICByZXR1cm4gX0ZyYWN0aW9uLnByb3RvdHlwZS5kaXZpZGUuY2FsbCh0aGlzLCB0aGlzLmRlY2ltYWxTY2FsZSkudG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRml4ZWQgPSBmdW5jdGlvbiB0b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZGVjaW1hbFBsYWNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWNpbWFsUGxhY2VzID0gdGhpcy5jdXJyZW5jeS5kZWNpbWFscztcbiAgICB9XG5cbiAgICBpZiAocm91bmRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgcm91bmRpbmcgPSBSb3VuZGluZy5ST1VORF9ET1dOO1xuICAgIH1cblxuICAgICEoZGVjaW1hbFBsYWNlcyA8PSB0aGlzLmN1cnJlbmN5LmRlY2ltYWxzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0RFQ0lNQUxTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBfRnJhY3Rpb24ucHJvdG90eXBlLmRpdmlkZS5jYWxsKHRoaXMsIHRoaXMuZGVjaW1hbFNjYWxlKS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpO1xuICB9O1xuXG4gIF9wcm90by50b0V4YWN0ID0gZnVuY3Rpb24gdG9FeGFjdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdCA9IHtcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIEJpZyQxLkRQID0gdGhpcy5jdXJyZW5jeS5kZWNpbWFscztcbiAgICByZXR1cm4gbmV3IEJpZyQxKHRoaXMucXVvdGllbnQudG9TdHJpbmcoKSkuZGl2KHRoaXMuZGVjaW1hbFNjYWxlLnRvU3RyaW5nKCkpLnRvRm9ybWF0KGZvcm1hdCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEN1cnJlbmN5QW1vdW50LCBbe1xuICAgIGtleTogXCJ3cmFwcGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW5jeS5pc1Rva2VuKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiBDdXJyZW5jeUFtb3VudC5mcm9tRnJhY3Rpb25hbEFtb3VudCh0aGlzLmN1cnJlbmN5LndyYXBwZWQsIHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3VycmVuY3lBbW91bnQ7XG59KEZyYWN0aW9uKTtcblxudmFyIE9ORV9IVU5EUkVEID0gLyojX19QVVJFX18qL25ldyBGcmFjdGlvbiggLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDEwMCkpO1xuLyoqXHJcbiAqIENvbnZlcnRzIGEgZnJhY3Rpb24gdG8gYSBwZXJjZW50XHJcbiAqIEBwYXJhbSBmcmFjdGlvbiB0aGUgZnJhY3Rpb24gdG8gY29udmVydFxyXG4gKi9cblxuZnVuY3Rpb24gdG9QZXJjZW50KGZyYWN0aW9uKSB7XG4gIHJldHVybiBuZXcgUGVyY2VudChmcmFjdGlvbi5udW1lcmF0b3IsIGZyYWN0aW9uLmRlbm9taW5hdG9yKTtcbn1cblxudmFyIFBlcmNlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9GcmFjdGlvbikge1xuICBfaW5oZXJpdHNMb29zZShQZXJjZW50LCBfRnJhY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIFBlcmNlbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRnJhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIC8qKlxyXG4gICAgICogVGhpcyBib29sZWFuIHByZXZlbnRzIGEgZnJhY3Rpb24gZnJvbSBiZWluZyBpbnRlcnByZXRlZCBhcyBhIFBlcmNlbnRcclxuICAgICAqL1xuXG4gICAgX3RoaXMuaXNQZXJjZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGVyY2VudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChvdGhlcikge1xuICAgIHJldHVybiB0b1BlcmNlbnQoX0ZyYWN0aW9uLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBvdGhlcikpO1xuICB9O1xuXG4gIF9wcm90by5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgcmV0dXJuIHRvUGVyY2VudChfRnJhY3Rpb24ucHJvdG90eXBlLnN1YnRyYWN0LmNhbGwodGhpcywgb3RoZXIpKTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShvdGhlcikge1xuICAgIHJldHVybiB0b1BlcmNlbnQoX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIG90aGVyKSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShvdGhlcikge1xuICAgIHJldHVybiB0b1BlcmNlbnQoX0ZyYWN0aW9uLnByb3RvdHlwZS5kaXZpZGUuY2FsbCh0aGlzLCBvdGhlcikpO1xuICB9O1xuXG4gIF9wcm90by50b1NpZ25pZmljYW50ID0gZnVuY3Rpb24gdG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZykge1xuICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9GcmFjdGlvbi5wcm90b3R5cGUubXVsdGlwbHkuY2FsbCh0aGlzLCBPTkVfSFVORFJFRCkudG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRml4ZWQgPSBmdW5jdGlvbiB0b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZGVjaW1hbFBsYWNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWNpbWFsUGxhY2VzID0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIE9ORV9IVU5EUkVEKS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpO1xuICB9O1xuXG4gIHJldHVybiBQZXJjZW50O1xufShGcmFjdGlvbik7XG5cbnZhciBQcmljZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0ZyYWN0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFByaWNlLCBfRnJhY3Rpb24pO1xuXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIHByaWNlLCBlaXRoZXIgd2l0aCB0aGUgYmFzZSBhbmQgcXVvdGUgY3VycmVuY3kgYW1vdW50LCBvciB0aGVcclxuICAgKiBAcGFyYW0gYXJnc1xyXG4gICAqL1xuICBmdW5jdGlvbiBQcmljZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgYmFzZUN1cnJlbmN5LCBxdW90ZUN1cnJlbmN5LCBkZW5vbWluYXRvciwgbnVtZXJhdG9yO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgYmFzZUN1cnJlbmN5ID0gYXJnc1swXTtcbiAgICAgIHF1b3RlQ3VycmVuY3kgPSBhcmdzWzFdO1xuICAgICAgZGVub21pbmF0b3IgPSBhcmdzWzJdO1xuICAgICAgbnVtZXJhdG9yID0gYXJnc1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3NbMF0ucXVvdGVBbW91bnQuZGl2aWRlKGFyZ3NbMF0uYmFzZUFtb3VudCk7XG4gICAgICB2YXIgX3JlZiA9IFthcmdzWzBdLmJhc2VBbW91bnQuY3VycmVuY3ksIGFyZ3NbMF0ucXVvdGVBbW91bnQuY3VycmVuY3ksIHJlc3VsdC5kZW5vbWluYXRvciwgcmVzdWx0Lm51bWVyYXRvcl07XG4gICAgICBiYXNlQ3VycmVuY3kgPSBfcmVmWzBdO1xuICAgICAgcXVvdGVDdXJyZW5jeSA9IF9yZWZbMV07XG4gICAgICBkZW5vbWluYXRvciA9IF9yZWZbMl07XG4gICAgICBudW1lcmF0b3IgPSBfcmVmWzNdO1xuICAgIH1cblxuICAgIF90aGlzID0gX0ZyYWN0aW9uLmNhbGwodGhpcywgbnVtZXJhdG9yLCBkZW5vbWluYXRvcikgfHwgdGhpcztcbiAgICBfdGhpcy5iYXNlQ3VycmVuY3kgPSBiYXNlQ3VycmVuY3k7XG4gICAgX3RoaXMucXVvdGVDdXJyZW5jeSA9IHF1b3RlQ3VycmVuY3k7XG4gICAgX3RoaXMuc2NhbGFyID0gbmV3IEZyYWN0aW9uKEpTQkkuZXhwb25lbnRpYXRlKEpTQkkuQmlnSW50KDEwKSwgSlNCSS5CaWdJbnQoYmFzZUN1cnJlbmN5LmRlY2ltYWxzKSksIEpTQkkuZXhwb25lbnRpYXRlKEpTQkkuQmlnSW50KDEwKSwgSlNCSS5CaWdJbnQocXVvdGVDdXJyZW5jeS5kZWNpbWFscykpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogRmxpcCB0aGUgcHJpY2UsIHN3aXRjaGluZyB0aGUgYmFzZSBhbmQgcXVvdGUgY3VycmVuY3lcclxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBQcmljZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmludmVydCA9IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICByZXR1cm4gbmV3IFByaWNlKHRoaXMucXVvdGVDdXJyZW5jeSwgdGhpcy5iYXNlQ3VycmVuY3ksIHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcbiAgfVxuICAvKipcclxuICAgKiBNdWx0aXBseSB0aGUgcHJpY2UgYnkgYW5vdGhlciBwcmljZSwgcmV0dXJuaW5nIGEgbmV3IHByaWNlLiBUaGUgb3RoZXIgcHJpY2UgbXVzdCBoYXZlIHRoZSBzYW1lIGJhc2UgY3VycmVuY3kgYXMgdGhpcyBwcmljZSdzIHF1b3RlIGN1cnJlbmN5XHJcbiAgICogQHBhcmFtIG90aGVyIHRoZSBvdGhlciBwcmljZVxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkob3RoZXIpIHtcbiAgICAhdGhpcy5xdW90ZUN1cnJlbmN5LmVxdWFscyhvdGhlci5iYXNlQ3VycmVuY3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVE9LRU4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgZnJhY3Rpb24gPSBfRnJhY3Rpb24ucHJvdG90eXBlLm11bHRpcGx5LmNhbGwodGhpcywgb3RoZXIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcmljZSh0aGlzLmJhc2VDdXJyZW5jeSwgb3RoZXIucXVvdGVDdXJyZW5jeSwgZnJhY3Rpb24uZGVub21pbmF0b3IsIGZyYWN0aW9uLm51bWVyYXRvcik7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBhbW91bnQgb2YgcXVvdGUgY3VycmVuY3kgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIGFtb3VudCBvZiB0aGUgYmFzZSBjdXJyZW5jeVxyXG4gICAqIEBwYXJhbSBjdXJyZW5jeUFtb3VudCB0aGUgYW1vdW50IG9mIGJhc2UgY3VycmVuY3kgdG8gcXVvdGUgYWdhaW5zdCB0aGUgcHJpY2VcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5xdW90ZSA9IGZ1bmN0aW9uIHF1b3RlKGN1cnJlbmN5QW1vdW50KSB7XG4gICAgIWN1cnJlbmN5QW1vdW50LmN1cnJlbmN5LmVxdWFscyh0aGlzLmJhc2VDdXJyZW5jeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdUT0tFTicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciByZXN1bHQgPSBfRnJhY3Rpb24ucHJvdG90eXBlLm11bHRpcGx5LmNhbGwodGhpcywgY3VycmVuY3lBbW91bnQpO1xuXG4gICAgcmV0dXJuIEN1cnJlbmN5QW1vdW50LmZyb21GcmFjdGlvbmFsQW1vdW50KHRoaXMucXVvdGVDdXJyZW5jeSwgcmVzdWx0Lm51bWVyYXRvciwgcmVzdWx0LmRlbm9taW5hdG9yKTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIHZhbHVlIHNjYWxlZCBieSBkZWNpbWFscyBmb3IgZm9ybWF0dGluZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TaWduaWZpY2FudCA9IGZ1bmN0aW9uIHRvU2lnbmlmaWNhbnQoc2lnbmlmaWNhbnREaWdpdHMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgPT09IHZvaWQgMCkge1xuICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSA2O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkanVzdGVkRm9yRGVjaW1hbHMudG9TaWduaWZpY2FudChzaWduaWZpY2FudERpZ2l0cywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvRml4ZWQgPSBmdW5jdGlvbiB0b0ZpeGVkKGRlY2ltYWxQbGFjZXMsIGZvcm1hdCwgcm91bmRpbmcpIHtcbiAgICBpZiAoZGVjaW1hbFBsYWNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWNpbWFsUGxhY2VzID0gNDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hZGp1c3RlZEZvckRlY2ltYWxzLnRvRml4ZWQoZGVjaW1hbFBsYWNlcywgZm9ybWF0LCByb3VuZGluZyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFByaWNlLCBbe1xuICAgIGtleTogXCJhZGp1c3RlZEZvckRlY2ltYWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX0ZyYWN0aW9uLnByb3RvdHlwZS5tdWx0aXBseS5jYWxsKHRoaXMsIHRoaXMuc2NhbGFyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJpY2U7XG59KEZyYWN0aW9uKTtcblxuLyoqXHJcbiAqIEEgY3VycmVuY3kgaXMgYW55IGZ1bmdpYmxlIGZpbmFuY2lhbCBpbnN0cnVtZW50LCBpbmNsdWRpbmcgRXRoZXIsIGFsbCBFUkMyMCB0b2tlbnMsIGFuZCBvdGhlciBjaGFpbi1uYXRpdmUgY3VycmVuY2llc1xyXG4gKi9cblxudmFyIEJhc2VDdXJyZW5jeSA9XG4vKipcclxuICogQ29uc3RydWN0cyBhbiBpbnN0YW5jZSBvZiB0aGUgYmFzZSBjbGFzcyBgQmFzZUN1cnJlbmN5YC5cclxuICogQHBhcmFtIGNoYWluSWQgdGhlIGNoYWluIElEIG9uIHdoaWNoIHRoaXMgY3VycmVuY3kgcmVzaWRlc1xyXG4gKiBAcGFyYW0gZGVjaW1hbHMgZGVjaW1hbHMgb2YgdGhlIGN1cnJlbmN5XHJcbiAqIEBwYXJhbSBzeW1ib2wgc3ltYm9sIG9mIHRoZSBjdXJyZW5jeVxyXG4gKiBAcGFyYW0gbmFtZSBvZiB0aGUgY3VycmVuY3lcclxuICovXG5mdW5jdGlvbiBCYXNlQ3VycmVuY3koY2hhaW5JZCwgZGVjaW1hbHMsIHN5bWJvbCwgbmFtZSkge1xuICAhTnVtYmVyLmlzU2FmZUludGVnZXIoY2hhaW5JZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDSEFJTl9JRCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIShkZWNpbWFscyA+PSAwICYmIGRlY2ltYWxzIDwgMjU1ICYmIE51bWJlci5pc0ludGVnZXIoZGVjaW1hbHMpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0RFQ0lNQUxTJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICB0aGlzLmRlY2ltYWxzID0gZGVjaW1hbHM7XG4gIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufTtcblxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIG5hdGl2ZSBjdXJyZW5jeSBvZiB0aGUgY2hhaW4gb24gd2hpY2ggaXQgcmVzaWRlcywgZS5nLlxyXG4gKi9cblxudmFyIE5hdGl2ZUN1cnJlbmN5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUN1cnJlbmN5KSB7XG4gIF9pbmhlcml0c0xvb3NlKE5hdGl2ZUN1cnJlbmN5LCBfQmFzZUN1cnJlbmN5KTtcblxuICBmdW5jdGlvbiBOYXRpdmVDdXJyZW5jeSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlQ3VycmVuY3kuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmlzTmF0aXZlID0gdHJ1ZTtcbiAgICBfdGhpcy5pc1Rva2VuID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIE5hdGl2ZUN1cnJlbmN5O1xufShCYXNlQ3VycmVuY3kpO1xuXG4vKipcclxuICogVmFsaWRhdGVzIGFuIGFkZHJlc3MgYW5kIHJldHVybnMgdGhlIHBhcnNlZCAoY2hlY2tzdW1tZWQpIHZlcnNpb24gb2YgdGhhdCBhZGRyZXNzXHJcbiAqIEBwYXJhbSBhZGRyZXNzIHRoZSB1bmNoZWNrc3VtbWVkIGhleCBhZGRyZXNzXHJcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhhZGRyZXNzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGFkZHJlc3MgKyBcIiBpcyBub3QgYSB2YWxpZCBhZGRyZXNzLlwiKTtcbiAgfVxufSAvLyBDaGVja3MgYSBzdHJpbmcgc3RhcnRzIHdpdGggMHgsIGlzIDQyIGNoYXJhY3RlcnMgbG9uZyBhbmQgY29udGFpbnMgb25seSBoZXggY2hhcmFjdGVycyBhZnRlciAweFxuXG52YXIgc3RhcnRzV2l0aDB4TGVuNDJIZXhSZWdleCA9IC9eMHhbMC05YS1mQS1GXXs0MH0kLztcbi8qKlxyXG4gKiBDaGVja3MgaWYgYW4gYWRkcmVzcyBpcyB2YWxpZCBieSBjaGVja2luZyAweCBwcmVmaXgsIGxlbmd0aCA9PT0gNDIgYW5kIGhleCBlbmNvZGluZy5cclxuICogQHBhcmFtIGFkZHJlc3MgdGhlIHVuY2hlY2tzdW1tZWQgaGV4IGFkZHJlc3NcclxuICovXG5cbmZ1bmN0aW9uIGNoZWNrVmFsaWRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgaWYgKHN0YXJ0c1dpdGgweExlbjQySGV4UmVnZXgudGVzdChhZGRyZXNzKSkge1xuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGFkZHJlc3MgKyBcIiBpcyBub3QgYSB2YWxpZCBhZGRyZXNzLlwiKTtcbn1cblxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gRVJDMjAgdG9rZW4gd2l0aCBhIHVuaXF1ZSBhZGRyZXNzIGFuZCBzb21lIG1ldGFkYXRhLlxyXG4gKi9cblxudmFyIFRva2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUN1cnJlbmN5KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRva2VuLCBfQmFzZUN1cnJlbmN5KTtcblxuICAvKipcclxuICAgKlxyXG4gICAqIEBwYXJhbSBjaGFpbklkIHtAbGluayBCYXNlQ3VycmVuY3kjY2hhaW5JZH1cclxuICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgY29udHJhY3QgYWRkcmVzcyBvbiB0aGUgY2hhaW4gb24gd2hpY2ggdGhpcyB0b2tlbiBsaXZlc1xyXG4gICAqIEBwYXJhbSBkZWNpbWFscyB7QGxpbmsgQmFzZUN1cnJlbmN5I2RlY2ltYWxzfVxyXG4gICAqIEBwYXJhbSBzeW1ib2wge0BsaW5rIEJhc2VDdXJyZW5jeSNzeW1ib2x9XHJcbiAgICogQHBhcmFtIG5hbWUge0BsaW5rIEJhc2VDdXJyZW5jeSNuYW1lfVxyXG4gICAqIEBwYXJhbSBieXBhc3NDaGVja3N1bSBJZiB0cnVlIGl0IG9ubHkgY2hlY2tzIGZvciBsZW5ndGggPT09IDQyLCBzdGFydHNXaXRoIDB4IGFuZCBjb250YWlucyBvbmx5IGhleCBjaGFyYWN0ZXJzXHJcbiAgICovXG4gIGZ1bmN0aW9uIFRva2VuKGNoYWluSWQsIGFkZHJlc3MsIGRlY2ltYWxzLCBzeW1ib2wsIG5hbWUsIGJ5cGFzc0NoZWNrc3VtKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZUN1cnJlbmN5LmNhbGwodGhpcywgY2hhaW5JZCwgZGVjaW1hbHMsIHN5bWJvbCwgbmFtZSkgfHwgdGhpcztcbiAgICBfdGhpcy5pc05hdGl2ZSA9IGZhbHNlO1xuICAgIF90aGlzLmlzVG9rZW4gPSB0cnVlO1xuXG4gICAgaWYgKGJ5cGFzc0NoZWNrc3VtKSB7XG4gICAgICBfdGhpcy5hZGRyZXNzID0gY2hlY2tWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmFkZHJlc3MgPSB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gdG9rZW5zIGFyZSBlcXVpdmFsZW50LCBpLmUuIGhhdmUgdGhlIHNhbWUgY2hhaW5JZCBhbmQgYWRkcmVzcy5cclxuICAgKiBAcGFyYW0gb3RoZXIgb3RoZXIgdG9rZW4gdG8gY29tcGFyZVxyXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFRva2VuLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzVG9rZW4gJiYgdGhpcy5jaGFpbklkID09PSBvdGhlci5jaGFpbklkICYmIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBvdGhlci5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIG9mIHRoaXMgdG9rZW4gc29ydHMgYmVmb3JlIHRoZSBhZGRyZXNzIG9mIHRoZSBvdGhlciB0b2tlblxyXG4gICAqIEBwYXJhbSBvdGhlciBvdGhlciB0b2tlbiB0byBjb21wYXJlXHJcbiAgICogQHRocm93cyBpZiB0aGUgdG9rZW5zIGhhdmUgdGhlIHNhbWUgYWRkcmVzc1xyXG4gICAqIEB0aHJvd3MgaWYgdGhlIHRva2VucyBhcmUgb24gZGlmZmVyZW50IGNoYWluc1xyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNvcnRzQmVmb3JlID0gZnVuY3Rpb24gc29ydHNCZWZvcmUob3RoZXIpIHtcbiAgICAhKHRoaXMuY2hhaW5JZCA9PT0gb3RoZXIuY2hhaW5JZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDSEFJTl9JRFMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gb3RoZXIuYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0FERFJFU1NFUycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPCBvdGhlci5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoaXMgdG9rZW4sIHdoaWNoIGRvZXMgbm90IG5lZWQgdG8gYmUgd3JhcHBlZFxyXG4gICAqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKFRva2VuLCBbe1xuICAgIGtleTogXCJ3cmFwcGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9rZW47XG59KEJhc2VDdXJyZW5jeSk7XG5cbnZhciBfV0VUSDtcbi8qKlxyXG4gKiBLbm93biBXRVRIOSBpbXBsZW1lbnRhdGlvbiBhZGRyZXNzZXMsIHVzZWQgaW4gb3VyIGltcGxlbWVudGF0aW9uIG9mIEV0aGVyI3dyYXBwZWRcclxuICovXG5cbnZhciBXRVRIOSA9IChfV0VUSCA9IHt9LCBfV0VUSFsxXSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oMSwgJzB4QzAyYWFBMzliMjIzRkU4RDBBMGU1QzRGMjdlQUQ5MDgzQzc1NkNjMicsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzNdID0gLyojX19QVVJFX18qL25ldyBUb2tlbigzLCAnMHhjNzc4NDE3RTA2MzE0MTEzOUZjZTAxMDk4Mjc4MDE0MEFhMGNENUFiJywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbNF0gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDQsICcweGM3Nzg0MTdFMDYzMTQxMTM5RmNlMDEwOTgyNzgwMTQwQWEwY0Q1QWInLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFs1XSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oNSwgJzB4QjRGQkYyNzExNDNGNEZCZjdCOTFBNWRlZDMxODA1ZTQyYjIyMDhkNicsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzQyXSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oNDIsICcweGQwQTFFMzU5ODExMzIyZDk3OTkxRTAzZjg2M2EwQzMwQzJjRjAyOUMnLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFsxMF0gPSAvKiNfX1BVUkVfXyovbmV3IFRva2VuKDEwLCAnMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2JywgMTgsICdXRVRIJywgJ1dyYXBwZWQgRXRoZXInKSwgX1dFVEhbNjldID0gLyojX19QVVJFX18qL25ldyBUb2tlbig2OSwgJzB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNicsIDE4LCAnV0VUSCcsICdXcmFwcGVkIEV0aGVyJyksIF9XRVRIWzQyMTYxXSA9IC8qI19fUFVSRV9fKi9uZXcgVG9rZW4oNDIxNjEsICcweDgyYUY0OTQ0N0Q4YTA3ZTNiZDk1QkQwZDU2ZjM1MjQxNTIzZkJhYjEnLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSFs0MjE2MTFdID0gLyojX19QVVJFX18qL25ldyBUb2tlbig0MjE2MTEsICcweEI0N2U2QTVmOGIzM2IzRjE3NjAzQzgzYTA1MzVBOWRjRDdFMzI2ODEnLCAxOCwgJ1dFVEgnLCAnV3JhcHBlZCBFdGhlcicpLCBfV0VUSCk7XG5cbi8qKlxyXG4gKiBFdGhlciBpcyB0aGUgbWFpbiB1c2FnZSBvZiBhICduYXRpdmUnIGN1cnJlbmN5LCBpLmUuIGZvciBFdGhlcmV1bSBtYWlubmV0IGFuZCBhbGwgdGVzdG5ldHNcclxuICovXG5cbnZhciBFdGhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05hdGl2ZUN1cnJlbmN5KSB7XG4gIF9pbmhlcml0c0xvb3NlKEV0aGVyLCBfTmF0aXZlQ3VycmVuY3kpO1xuXG4gIGZ1bmN0aW9uIEV0aGVyKGNoYWluSWQpIHtcbiAgICByZXR1cm4gX05hdGl2ZUN1cnJlbmN5LmNhbGwodGhpcywgY2hhaW5JZCwgMTgsICdFVEgnLCAnRXRoZXInKSB8fCB0aGlzO1xuICB9XG5cbiAgRXRoZXIub25DaGFpbiA9IGZ1bmN0aW9uIG9uQ2hhaW4oY2hhaW5JZCkge1xuICAgIHZhciBfdGhpcyRfZXRoZXJDYWNoZSRjaGE7XG5cbiAgICByZXR1cm4gKF90aGlzJF9ldGhlckNhY2hlJGNoYSA9IHRoaXMuX2V0aGVyQ2FjaGVbY2hhaW5JZF0pICE9IG51bGwgPyBfdGhpcyRfZXRoZXJDYWNoZSRjaGEgOiB0aGlzLl9ldGhlckNhY2hlW2NoYWluSWRdID0gbmV3IEV0aGVyKGNoYWluSWQpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBFdGhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5pc05hdGl2ZSAmJiBvdGhlci5jaGFpbklkID09PSB0aGlzLmNoYWluSWQ7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEV0aGVyLCBbe1xuICAgIGtleTogXCJ3cmFwcGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgd2V0aDkgPSBXRVRIOVt0aGlzLmNoYWluSWRdO1xuICAgICAgISEhd2V0aDkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdXUkFQUEVEJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHdldGg5O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdGhlcjtcbn0oTmF0aXZlQ3VycmVuY3kpO1xuRXRoZXIuX2V0aGVyQ2FjaGUgPSB7fTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHBlcmNlbnQgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBtaWQgcHJpY2UgYW5kIHRoZSBleGVjdXRpb24gcHJpY2UsIGkuZS4gcHJpY2UgaW1wYWN0LlxyXG4gKiBAcGFyYW0gbWlkUHJpY2UgbWlkIHByaWNlIGJlZm9yZSB0aGUgdHJhZGVcclxuICogQHBhcmFtIGlucHV0QW1vdW50IHRoZSBpbnB1dCBhbW91bnQgb2YgdGhlIHRyYWRlXHJcbiAqIEBwYXJhbSBvdXRwdXRBbW91bnQgdGhlIG91dHB1dCBhbW91bnQgb2YgdGhlIHRyYWRlXHJcbiAqL1xuXG5mdW5jdGlvbiBjb21wdXRlUHJpY2VJbXBhY3QobWlkUHJpY2UsIGlucHV0QW1vdW50LCBvdXRwdXRBbW91bnQpIHtcbiAgdmFyIHF1b3RlZE91dHB1dEFtb3VudCA9IG1pZFByaWNlLnF1b3RlKGlucHV0QW1vdW50KTsgLy8gY2FsY3VsYXRlIHByaWNlIGltcGFjdCA6PSAoZXhhY3RRdW90ZSAtIG91dHB1dEFtb3VudCkgLyBleGFjdFF1b3RlXG5cbiAgdmFyIHByaWNlSW1wYWN0ID0gcXVvdGVkT3V0cHV0QW1vdW50LnN1YnRyYWN0KG91dHB1dEFtb3VudCkuZGl2aWRlKHF1b3RlZE91dHB1dEFtb3VudCk7XG4gIHJldHVybiBuZXcgUGVyY2VudChwcmljZUltcGFjdC5udW1lcmF0b3IsIHByaWNlSW1wYWN0LmRlbm9taW5hdG9yKTtcbn1cblxuLy8gYG1heFNpemVgIGJ5IHJlbW92aW5nIHRoZSBsYXN0IGl0ZW1cblxuZnVuY3Rpb24gc29ydGVkSW5zZXJ0KGl0ZW1zLCBhZGQsIG1heFNpemUsIGNvbXBhcmF0b3IpIHtcbiAgIShtYXhTaXplID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNQVhfU0laRV9aRVJPJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwOyAvLyB0aGlzIGlzIGFuIGludmFyaWFudCBiZWNhdXNlIHRoZSBpbnRlcmZhY2UgY2Fubm90IHJldHVybiBtdWx0aXBsZSByZW1vdmVkIGl0ZW1zIGlmIGl0ZW1zLmxlbmd0aCBleGNlZWRzIG1heFNpemVcblxuICAhKGl0ZW1zLmxlbmd0aCA8PSBtYXhTaXplKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0lURU1TX1NJWkUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7IC8vIHNob3J0IGNpcmN1aXQgZmlyc3QgaXRlbSBhZGRcblxuICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgaXRlbXMucHVzaChhZGQpO1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciBpc0Z1bGwgPSBpdGVtcy5sZW5ndGggPT09IG1heFNpemU7IC8vIHNob3J0IGNpcmN1aXQgaWYgZnVsbCBhbmQgdGhlIGFkZGl0aW9uYWwgaXRlbSBkb2VzIG5vdCBjb21lIGJlZm9yZSB0aGUgbGFzdCBpdGVtXG5cbiAgICBpZiAoaXNGdWxsICYmIGNvbXBhcmF0b3IoaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0sIGFkZCkgPD0gMCkge1xuICAgICAgcmV0dXJuIGFkZDtcbiAgICB9XG5cbiAgICB2YXIgbG8gPSAwLFxuICAgICAgICBoaSA9IGl0ZW1zLmxlbmd0aDtcblxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbXNbbWlkXSwgYWRkKSA8PSAwKSB7XG4gICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpID0gbWlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGl0ZW1zLnNwbGljZShsbywgMCwgYWRkKTtcbiAgICByZXR1cm4gaXNGdWxsID8gaXRlbXMucG9wKCkgOiBudWxsO1xuICB9XG59XG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbnZhciBaRVJPID0gLyojX19QVVJFX18qL0pTQkkuQmlnSW50KDApO1xudmFyIE9ORSA9IC8qI19fUFVSRV9fKi9KU0JJLkJpZ0ludCgxKTtcbnZhciBUV08gPSAvKiNfX1BVUkVfXyovSlNCSS5CaWdJbnQoMik7XG4vKipcclxuICogQ29tcHV0ZXMgZmxvb3Ioc3FydCh2YWx1ZSkpXHJcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIHNxdWFyZSByb290LCByb3VuZGVkIGRvd25cclxuICovXG5cbmZ1bmN0aW9uIHNxcnQodmFsdWUpIHtcbiAgIUpTQkkuZ3JlYXRlclRoYW5PckVxdWFsKHZhbHVlLCBaRVJPKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ05FR0FUSVZFJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwOyAvLyByZWx5IG9uIGJ1aWx0IGluIHNxcnQgaWYgcG9zc2libGVcblxuICBpZiAoSlNCSS5sZXNzVGhhbih2YWx1ZSwgTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICByZXR1cm4gSlNCSS5CaWdJbnQoTWF0aC5mbG9vcihNYXRoLnNxcnQoSlNCSS50b051bWJlcih2YWx1ZSkpKSk7XG4gIH1cblxuICB2YXIgejtcbiAgdmFyIHg7XG4gIHogPSB2YWx1ZTtcbiAgeCA9IEpTQkkuYWRkKEpTQkkuZGl2aWRlKHZhbHVlLCBUV08pLCBPTkUpO1xuXG4gIHdoaWxlIChKU0JJLmxlc3NUaGFuKHgsIHopKSB7XG4gICAgeiA9IHg7XG4gICAgeCA9IEpTQkkuZGl2aWRlKEpTQkkuYWRkKEpTQkkuZGl2aWRlKHZhbHVlLCB4KSwgeCksIFRXTyk7XG4gIH1cblxuICByZXR1cm4gejtcbn1cblxuZXhwb3J0IHsgQ3VycmVuY3lBbW91bnQsIEV0aGVyLCBGcmFjdGlvbiwgTWF4VWludDI1NiwgTmF0aXZlQ3VycmVuY3ksIFBlcmNlbnQsIFByaWNlLCBSb3VuZGluZywgU3VwcG9ydGVkQ2hhaW5JZCwgVG9rZW4sIFRyYWRlVHlwZSwgV0VUSDksIGNvbXB1dGVQcmljZUltcGFjdCwgc29ydGVkSW5zZXJ0LCBzcXJ0LCB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2RrLWNvcmUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@uniswap/v2-sdk/node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js\n");

/***/ })

};
;